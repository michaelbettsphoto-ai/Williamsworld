<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, user-scalable=no">
  <title>William's World - Battle Screen</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700;900&family=Fredoka+One&family=Nunito:wght@400;600;700;800&family=Permanent+Marker&display=swap" rel="stylesheet">
  <style>
/* ===== DESIGN: Storybook Battlegrounds ‚Äî Pok√©mon Cartoon Edition =====
   Full animation system: every action animates like a Pok√©mon episode.
   Hero leveling with 3 ranks (Starter ‚Üí Expert ‚Üí Legendary).
   ================================================================== */

:root {
  --bg: #0f0a1c;
  --panel: rgba(18, 11, 32, 0.85);
  --panel-strong: rgba(25, 14, 45, 0.92);
  --text: #fff5e6;
  --text-secondary: #e6d4b8;
  --muted: rgba(255, 245, 230, 0.6);
  --gold: #ffd36e;
  --gold-dark: #c8942a;
  --green: #7dffb4;
  --green-dark: #34d399;
  --blue: #60a5fa;
  --red: #ef4444;
  --red-dark: #dc2626;
  --purple: #a78bfa;
  --orange: #ff9d5c;
  --cyan: #22d3ee;
  --card-bg: rgba(30, 15, 40, 0.95);
  --card-border: rgba(255, 255, 255, 0.16);
  --glass-bg: rgba(20, 10, 35, 0.3);
  --glass-blur: blur(14px) saturate(1.3);
  --glass-border: rgba(255, 255, 255, 0.1);
  --font: 'Nunito', ui-sans-serif, system-ui, sans-serif;
  --font-display: 'Cinzel', serif;
  --font-action: 'Fredoka One', cursive;
  --font-comic: 'Permanent Marker', cursive;
  --radius-lg: 18px;
  --radius-md: 12px;
  --radius-sm: 8px;
  --shadow: 0 12px 40px rgba(0,0,0,0.45);
  --type-fire: #ef4444; --type-water: #3b82f6; --type-grass: #22c55e;
  --type-electric: #eab308; --type-ice: #06b6d4; --type-rock: #78716c;
  --type-shadow: #6366f1; --type-light: #fbbf24; --type-wind: #14b8a6;
  --type-metal: #94a3b8; --type-neutral: #a8a29e;
  --rarity-common: rgba(255,255,255,0.4); --rarity-uncommon: #22c55e;
  --rarity-rare: #3b82f6; --rarity-elite: #a855f7;
}

* { margin: 0; padding: 0; box-sizing: border-box; }
html, body { height: 100%; overflow: hidden; }
body {
  font-family: var(--font);
  background: var(--bg);
  color: var(--text);
  position: relative;
  user-select: none;
  -webkit-user-select: none;
}

/* ===== NAVIGATION ===== */
.nav-bar {
  position: fixed; top: 0; left: 0; right: 0; z-index: 100;
  display: flex; align-items: center; padding: 8px 16px;
  background: rgba(15, 10, 28, 0.7);
  backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
  border-bottom: 1px solid rgba(255,255,255,0.08);
}
.back-btn {
  display: flex; align-items: center; gap: 6px;
  background: rgba(255,211,110,0.15); border: 1px solid rgba(255,211,110,0.3);
  color: var(--gold); font-family: var(--font); font-size: 0.85rem; font-weight: 700;
  padding: 6px 14px; border-radius: 20px; cursor: pointer;
  transition: all 0.2s ease;
}
.back-btn:hover { background: rgba(255,211,110,0.3); transform: scale(1.05); }
.back-btn svg { width: 16px; height: 16px; }
.nav-title {
  flex: 1; text-align: center;
  font-family: var(--font-display); font-size: 1rem; color: var(--gold);
  letter-spacing: 0.05em;
}
.nav-streak {
  font-family: var(--font); font-size: 0.8rem; color: var(--text-secondary);
  display: flex; align-items: center; gap: 4px;
}

/* ===== LOCKED ZONE STYLES ===== */
.zone-chip.locked {
  opacity: 0.45; filter: grayscale(0.6);
  cursor: not-allowed;
  border-color: rgba(255,255,255,0.08) !important;
  background: rgba(30, 15, 40, 0.6) !important;
}
.zone-chip.locked:hover { transform: none; }

@keyframes shake-deny {
  0%, 100% { transform: translateX(0); }
  20% { transform: translateX(-6px); }
  40% { transform: translateX(6px); }
  60% { transform: translateX(-4px); }
  80% { transform: translateX(4px); }
}
.shake-deny { animation: shake-deny 0.4s ease; }

.zone-lock-msg {
  font-family: var(--font); font-size: 0.75rem; color: var(--orange);
  text-align: center; margin-top: 4px;
  opacity: 0.8;
}

/* ===== BACKGROUND ===== */
#battle-bg {
  position: fixed; inset: 0;
  background-size: cover; background-position: center;
  transition: background-image 0.8s ease;
  z-index: 0;
}
#battle-bg::after {
  content: ''; position: absolute; inset: 0;
  background: linear-gradient(180deg, rgba(8,5,18,0.15) 0%, rgba(8,5,18,0.35) 40%, rgba(8,5,18,0.75) 100%);
  pointer-events: none;
}

/* ===== VFX OVERLAY (for screen-wide effects) ===== */
#vfx-overlay {
  position: fixed; inset: 0; z-index: 500; pointer-events: none;
}

/* ===== PARTICLES ===== */
.particle {
  position: fixed; width: 4px; height: 4px; border-radius: 50%;
  background: var(--gold); opacity: 0; pointer-events: none; z-index: 1;
  animation: floatParticle 6s ease-in-out infinite;
}
@keyframes floatParticle {
  0%, 100% { opacity: 0; transform: translateY(0) scale(0.5); }
  20% { opacity: 0.8; } 80% { opacity: 0.4; }
  100% { transform: translateY(-120px) scale(0); }
}

/* ===== SCREEN LAYERS ===== */
.screen {
  position: fixed; inset: 0; z-index: 10;
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  transition: opacity 0.5s ease, transform 0.5s ease;
  pointer-events: none; opacity: 0;
}
.screen.active { pointer-events: auto; opacity: 1; }
.screen.exit { opacity: 0; transform: scale(0.95); }

/* ===== SCREEN 1: ZONE SELECT ===== */
#scout-screen { gap: 24px; padding: 24px; padding-top: 56px; }
#draw-screen { padding-top: 56px; }
#battle-screen { padding-top: 48px; }
#result-screen { padding-top: 56px; }
#evolution-screen { padding-top: 56px; }
.zone-title {
  font-family: var(--font-display); font-size: clamp(1.8rem, 5vw, 3rem);
  font-weight: 900; color: var(--gold);
  text-shadow: 0 2px 20px rgba(255,211,110,0.4), 0 0 60px rgba(255,211,110,0.15);
  text-align: center; letter-spacing: 0.04em;
}
.zone-subtitle {
  font-size: clamp(0.9rem, 2.5vw, 1.1rem); color: var(--text-secondary);
  text-align: center; max-width: 400px; line-height: 1.5;
}
.zone-badge {
  display: inline-flex; align-items: center; gap: 8px; padding: 6px 16px;
  background: var(--glass-bg); backdrop-filter: var(--glass-blur);
  border: 1px solid var(--glass-border); border-radius: 20px;
  font-size: 0.85rem; color: var(--cyan);
}
/* XP bar on zone screen */
.xp-display {
  display: flex; flex-direction: column; align-items: center; gap: 6px;
  padding: 8px 24px; background: var(--glass-bg); backdrop-filter: var(--glass-blur);
  border: 1px solid var(--glass-border); border-radius: var(--radius-md);
}
.xp-label { font-size: 0.75rem; color: var(--muted); }
.xp-bar-outer {
  width: 200px; height: 10px; background: rgba(255,255,255,0.1);
  border-radius: 5px; overflow: hidden;
}
.xp-bar-inner {
  height: 100%; background: linear-gradient(90deg, var(--purple), var(--cyan));
  border-radius: 5px; transition: width 0.8s ease;
}
.rank-badges { display: flex; gap: 8px; align-items: center; }
.rank-badge {
  padding: 3px 10px; border-radius: 12px; font-size: 0.7rem; font-weight: 700;
  text-transform: uppercase;
}
.rank-badge.starter { background: rgba(168,162,158,0.3); color: #a8a29e; }
.rank-badge.expert { background: rgba(59,130,246,0.3); color: #60a5fa; border: 1px solid rgba(59,130,246,0.4); }
.rank-badge.legendary { background: rgba(255,211,110,0.2); color: var(--gold); border: 1px solid rgba(255,211,110,0.4); }
.rank-badge.active { box-shadow: 0 0 12px currentColor; }

.scout-btn {
  position: relative; padding: 18px 48px;
  font-family: var(--font-action); font-size: clamp(1.2rem, 3vw, 1.6rem);
  color: #1a0e2e; background: linear-gradient(135deg, var(--gold), #ffb347);
  border: none; border-radius: 50px; cursor: pointer;
  box-shadow: 0 6px 30px rgba(255,211,110,0.4), inset 0 2px 0 rgba(255,255,255,0.3);
  transition: all 0.2s ease; overflow: hidden; z-index: 1;
}
.scout-btn:hover { transform: translateY(-2px) scale(1.03); box-shadow: 0 8px 40px rgba(255,211,110,0.6); }
.scout-btn:active { transform: translateY(1px) scale(0.98); }
.scout-btn .shimmer {
  position: absolute; top: 0; left: -100%; width: 100%; height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
  animation: btnShimmer 3s ease-in-out infinite;
}
@keyframes btnShimmer { 0% { left: -100%; } 50%, 100% { left: 100%; } }

.zone-selector { display: flex; gap: 12px; flex-wrap: wrap; justify-content: center; margin-top: 8px; }
.zone-chip {
  padding: 8px 20px; font-family: var(--font); font-size: 0.85rem; font-weight: 700;
  color: var(--text-secondary); background: var(--glass-bg); backdrop-filter: var(--glass-blur);
  border: 1px solid var(--glass-border); border-radius: 20px; cursor: pointer; transition: all 0.2s;
}
.zone-chip:hover { border-color: var(--gold); color: var(--gold); }
.zone-chip.active { border-color: var(--gold); color: var(--gold); background: rgba(255,211,110,0.1); }

/* ===== SCREEN 2: CARD DRAW ===== */
#draw-screen { gap: 20px; padding: 20px; }
.draw-title {
  font-family: var(--font-comic); font-size: clamp(1.4rem, 4vw, 2.2rem);
  color: var(--gold); text-shadow: 0 2px 10px rgba(255,211,110,0.5);
}
.draw-area {
  display: flex; gap: clamp(12px, 3vw, 24px); align-items: center;
  justify-content: center; perspective: 1000px;
}
.draw-card-slot {
  width: clamp(100px, 22vw, 160px); height: clamp(140px, 31vw, 224px);
  position: relative; transform-style: preserve-3d;
}
.draw-card-inner {
  width: 100%; height: 100%; position: relative; transform-style: preserve-3d;
  transition: transform 0.8s cubic-bezier(0.4, 0, 0.2, 1);
}
.draw-card-inner.flipped { transform: rotateY(180deg); }
.draw-card-face {
  position: absolute; inset: 0; backface-visibility: hidden;
  border-radius: var(--radius-md); overflow: hidden;
}
.draw-card-back {
  background: url('https://files.manuscdn.com/user_upload_by_module/session_file/310519663346319809/aBsHEkiCJJbvcNLB.png') center/cover;
  border: 2px solid var(--gold-dark);
  box-shadow: 0 4px 20px rgba(0,0,0,0.5), 0 0 15px rgba(255,211,110,0.2);
}
.draw-card-front {
  transform: rotateY(180deg); background: var(--card-bg);
  border: 2px solid var(--card-border);
  display: flex; flex-direction: column; align-items: center; padding: 8px; gap: 4px;
}
.draw-card-front .enemy-portrait {
  width: 100%; flex: 1; border-radius: var(--radius-sm);
  display: flex; align-items: center; justify-content: center;
  font-size: 2.5rem; position: relative; overflow: hidden;
}
.draw-card-front .enemy-name {
  font-family: var(--font-display); font-size: clamp(0.6rem, 1.8vw, 0.85rem);
  font-weight: 700; color: var(--gold); text-align: center; line-height: 1.2;
}
.draw-card-front .enemy-info { display: flex; gap: 6px; align-items: center; font-size: 0.65rem; }
.element-badge {
  padding: 2px 8px; border-radius: 10px; font-size: 0.6rem;
  font-weight: 700; text-transform: uppercase; letter-spacing: 0.05em;
}
.rarity-badge {
  padding: 2px 8px; border-radius: 10px; font-size: 0.6rem;
  font-weight: 700; text-transform: uppercase;
}
.enemy-deck {
  position: relative; width: clamp(80px, 18vw, 120px); height: clamp(112px, 25vw, 168px);
}
.deck-stack {
  position: absolute; width: 100%; height: 100%;
  background: url('https://files.manuscdn.com/user_upload_by_module/session_file/310519663346319809/aBsHEkiCJJbvcNLB.png') center/cover;
  border-radius: var(--radius-md); border: 2px solid var(--gold-dark);
  box-shadow: 0 4px 20px rgba(0,0,0,0.5);
}
.deck-stack:nth-child(1) { top: 0; left: 0; }
.deck-stack:nth-child(2) { top: 3px; left: 3px; }
.deck-stack:nth-child(3) { top: 6px; left: 6px; }
.deck-glow {
  position: absolute; inset: -8px;
  border-radius: calc(var(--radius-md) + 8px);
  background: radial-gradient(ellipse, rgba(255,211,110,0.3), transparent 70%);
  animation: deckPulse 2s ease-in-out infinite;
}
@keyframes deckPulse { 0%, 100% { opacity: 0.5; transform: scale(1); } 50% { opacity: 1; transform: scale(1.05); } }

/* ===== SCREEN 3: BATTLE FIELD ===== */
#battle-screen { padding: 8px; gap: 0; justify-content: space-between; }
.battle-hud {
  width: 100%; display: flex; justify-content: space-between; align-items: center;
  padding: 8px 12px; background: var(--glass-bg); backdrop-filter: var(--glass-blur);
  border-bottom: 1px solid var(--glass-border); border-radius: var(--radius-md); z-index: 20;
}
.hud-left, .hud-right { display: flex; align-items: center; gap: 12px; }
.round-counter { font-family: var(--font-display); font-size: 0.9rem; color: var(--gold); }
.combo-meter {
  font-family: var(--font-comic); font-size: 0.85rem; color: var(--orange);
  opacity: 0; transition: opacity 0.3s;
}
.combo-meter.visible { opacity: 1; animation: comboPulse 0.6s ease; }
@keyframes comboPulse { 0% { transform: scale(1); } 50% { transform: scale(1.3); } 100% { transform: scale(1); } }
.phase-indicator {
  font-size: 0.75rem; color: var(--text-secondary); padding: 4px 12px;
  background: rgba(255,255,255,0.06); border-radius: 12px;
  transition: all 0.3s;
}
.phase-indicator.your-turn { color: var(--green); background: rgba(125,255,180,0.1); }
.phase-indicator.enemy-turn { color: var(--red); background: rgba(239,68,68,0.1); }

/* Turn order bar */
.turn-order-bar {
  display: flex; gap: 4px; align-items: center; padding: 4px 8px;
  background: rgba(0,0,0,0.3); border-radius: 12px; overflow: hidden;
}
.turn-order-icon {
  width: 28px; height: 28px; border-radius: 50%; border: 2px solid var(--card-border);
  overflow: hidden; transition: all 0.3s;
}
.turn-order-icon.active-turn { border-color: var(--gold); box-shadow: 0 0 10px rgba(255,211,110,0.5); transform: scale(1.15); }
.turn-order-icon img { width: 100%; height: 100%; object-fit: cover; }
.turn-order-arrow { color: var(--muted); font-size: 0.6rem; }

/* Battle field */
.battle-field {
  flex: 1; width: 100%; display: flex; flex-direction: column;
  justify-content: space-between; padding: 8px 0; gap: 8px;
  max-width: 900px; margin: 0 auto;
}
.card-row { display: flex; justify-content: center; gap: clamp(8px, 2vw, 16px); padding: 4px 0; }

/* Battle cards */
.battle-card {
  width: clamp(100px, 28vw, 160px); background: var(--card-bg);
  border: 2px solid var(--card-border); border-radius: var(--radius-md);
  padding: 8px; display: flex; flex-direction: column; gap: 4px;
  position: relative; transition: all 0.3s ease; cursor: default;
  box-shadow: var(--shadow);
}
.battle-card.hero-card { cursor: pointer; }
.battle-card.hero-card:hover { transform: translateY(-4px); box-shadow: 0 16px 50px rgba(0,0,0,0.5), 0 0 20px rgba(255,211,110,0.15); }
.battle-card.hero-card.selected { border-color: var(--gold); box-shadow: 0 0 20px rgba(255,211,110,0.4), 0 12px 40px rgba(0,0,0,0.5); }
.battle-card.defeated { opacity: 0.35; filter: grayscale(0.8); pointer-events: none; }
.battle-card.enemy-card.targeted { border-color: var(--red); box-shadow: 0 0 15px rgba(239,68,68,0.4); animation: targetPulse 1s ease-in-out infinite; }
@keyframes targetPulse { 0%, 100% { box-shadow: 0 0 15px rgba(239,68,68,0.4); } 50% { box-shadow: 0 0 25px rgba(239,68,68,0.7); } }

.card-portrait {
  width: 100%; height: clamp(50px, 12vw, 80px); border-radius: var(--radius-sm);
  overflow: hidden; display: flex; align-items: center; justify-content: center; position: relative;
}
.card-portrait img {
  width: 100%; height: 100%; object-fit: cover;
}
/* William's art is full-body, so we crop to show upper body */
.card-portrait img[data-hero="william"] {
  object-fit: cover;
  object-position: center 15%;
}
.card-portrait .emoji-portrait { font-size: 2rem; }
.card-role-badge {
  position: absolute; top: 2px; right: 2px; font-size: 0.55rem; padding: 1px 6px;
  border-radius: 8px; background: rgba(0,0,0,0.6); color: var(--text);
  font-weight: 700; text-transform: uppercase;
}
.card-rank-star {
  position: absolute; top: 2px; left: 2px; font-size: 0.55rem; padding: 1px 5px;
  border-radius: 8px; background: rgba(0,0,0,0.6); color: var(--gold);
  font-weight: 700;
}
.card-name {
  font-family: var(--font-display); font-size: clamp(0.6rem, 1.6vw, 0.8rem);
  font-weight: 700; color: var(--gold); text-align: center; line-height: 1.2;
  white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}
.card-subtitle { font-size: 0.55rem; color: var(--muted); text-align: center; }

/* HP Bar */
.hp-bar-container { width: 100%; display: flex; align-items: center; gap: 4px; }
.hp-bar { flex: 1; height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; overflow: hidden; position: relative; }
.hp-bar-fill {
  height: 100%; background: linear-gradient(90deg, var(--green-dark), var(--green));
  border-radius: 4px; transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1); position: relative;
}
.hp-bar-fill.low { background: linear-gradient(90deg, var(--red-dark), var(--red)); animation: hpCritical 1s ease-in-out infinite; }
.hp-bar-fill.mid { background: linear-gradient(90deg, #d97706, var(--orange)); }
@keyframes hpCritical { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
.hp-bar-fill::after {
  content: ''; position: absolute; top: 0; left: 0; right: 0; height: 50%;
  background: rgba(255,255,255,0.2); border-radius: 4px 4px 0 0;
}
.hp-text { font-size: 0.6rem; font-weight: 700; color: var(--text); min-width: 36px; text-align: right; }

/* Status icons */
.status-row { display: flex; gap: 3px; flex-wrap: wrap; min-height: 16px; }
.status-icon {
  font-size: 0.6rem; padding: 1px 5px; border-radius: 6px;
  background: rgba(255,255,255,0.08); display: flex; align-items: center; gap: 2px;
  animation: statusPop 0.3s ease-out;
}
@keyframes statusPop { 0% { transform: scale(0); } 50% { transform: scale(1.3); } 100% { transform: scale(1); } }

/* Lane divider */
.lane-divider { width: 100%; display: flex; justify-content: center; align-items: center; padding: 4px 0; gap: 8px; }
.lane-line { height: 2px; flex: 1; max-width: 200px; background: linear-gradient(90deg, transparent, var(--gold-dark), transparent); opacity: 0.3; }
.lane-vs { font-family: var(--font-comic); font-size: 0.9rem; color: var(--gold); opacity: 0.6; }

/* ===== ACTION PANEL ===== */
.action-panel {
  width: 100%; max-width: 900px; margin: 0 auto;
  background: var(--panel-strong); backdrop-filter: var(--glass-blur);
  border: 1px solid var(--glass-border); border-radius: var(--radius-lg) var(--radius-lg) 0 0;
  padding: 12px; display: flex; flex-direction: column; gap: 8px; z-index: 20;
}
.action-label { font-size: 0.75rem; color: var(--muted); text-align: center; }
.action-buttons { display: flex; gap: 8px; justify-content: center; flex-wrap: wrap; }
.action-btn {
  flex: 1; min-width: 80px; max-width: 180px; padding: 10px 12px;
  font-family: var(--font); font-size: 0.75rem; font-weight: 700;
  color: var(--text); background: rgba(255,255,255,0.06);
  border: 1px solid rgba(255,255,255,0.12); border-radius: var(--radius-sm);
  cursor: pointer; transition: all 0.2s; display: flex; flex-direction: column;
  align-items: center; gap: 2px; position: relative;
}
.action-btn:hover:not(:disabled) { background: rgba(255,255,255,0.12); border-color: var(--gold); transform: translateY(-2px); }
.action-btn:active:not(:disabled) { transform: translateY(0); }
.action-btn:disabled { opacity: 0.35; cursor: not-allowed; }
.action-btn.selected { border-color: var(--gold) !important; background: rgba(255,211,110,0.15) !important; }
.action-btn .move-name { font-family: var(--font-action); font-size: 0.8rem; color: var(--gold); }
.action-btn .move-desc { font-size: 0.6rem; color: var(--muted); line-height: 1.2; }
.action-btn .cooldown-badge {
  position: absolute; top: -4px; right: -4px; width: 18px; height: 18px;
  border-radius: 50%; background: var(--red); color: white;
  font-size: 0.6rem; font-weight: 700; display: flex; align-items: center; justify-content: center;
}
.action-btn.guard-btn { border-color: var(--blue); }
.action-btn.guard-btn:hover { background: rgba(96,165,250,0.15); }
.confirm-btn {
  padding: 10px 32px; font-family: var(--font-action); font-size: 1rem;
  color: #1a0e2e; background: linear-gradient(135deg, var(--gold), #ffb347);
  border: none; border-radius: 30px; cursor: pointer;
  box-shadow: 0 4px 20px rgba(255,211,110,0.3); transition: all 0.2s; align-self: center;
}
.confirm-btn:hover { transform: scale(1.05); }

/* ===== SCREEN 4: RESULT ===== */
#result-screen { gap: 24px; padding: 24px; }
.result-title {
  font-family: var(--font-display); font-size: clamp(2rem, 6vw, 3.5rem);
  font-weight: 900; text-shadow: 0 4px 30px rgba(255,211,110,0.5);
}
.result-title.win { color: var(--gold); animation: victoryBounce 0.8s ease; }
.result-title.lose { color: var(--red); }
@keyframes victoryBounce {
  0% { transform: scale(0); opacity: 0; }
  50% { transform: scale(1.2); }
  70% { transform: scale(0.95); }
  100% { transform: scale(1); opacity: 1; }
}
.result-subtitle { font-size: 1.1rem; color: var(--text-secondary); text-align: center; }
.reward-list {
  display: flex; flex-direction: column; gap: 8px; padding: 16px 24px;
  background: var(--glass-bg); backdrop-filter: var(--glass-blur);
  border: 1px solid var(--glass-border); border-radius: var(--radius-md);
}
.reward-item { display: flex; align-items: center; gap: 10px; font-size: 0.95rem; animation: rewardSlide 0.4s ease-out both; }
@keyframes rewardSlide { 0% { opacity: 0; transform: translateX(-20px); } 100% { opacity: 1; transform: translateX(0); } }
.reward-icon { font-size: 1.3rem; }
.reward-text { color: var(--text-secondary); }
.reward-value { color: var(--gold); font-weight: 700; margin-left: auto; }
.result-btn {
  padding: 14px 40px; font-family: var(--font-action); font-size: 1.2rem;
  color: #1a0e2e; background: linear-gradient(135deg, var(--gold), #ffb347);
  border: none; border-radius: 50px; cursor: pointer;
  box-shadow: 0 6px 30px rgba(255,211,110,0.4); transition: all 0.2s;
}
.result-btn:hover { transform: translateY(-2px) scale(1.03); }

/* ===== EVOLUTION SCREEN ===== */
#evolution-screen {
  gap: 24px; padding: 24px; z-index: 300;
}
.evo-title {
  font-family: var(--font-display); font-size: clamp(1.5rem, 4vw, 2.5rem);
  font-weight: 900; color: var(--gold);
  text-shadow: 0 0 40px rgba(255,211,110,0.6);
  animation: evoPulse 1.5s ease-in-out infinite;
}
@keyframes evoPulse { 0%, 100% { text-shadow: 0 0 40px rgba(255,211,110,0.6); } 50% { text-shadow: 0 0 80px rgba(255,211,110,1); } }
.evo-container {
  display: flex; align-items: center; gap: 32px; justify-content: center;
}
.evo-card {
  width: 160px; height: 200px; border-radius: var(--radius-lg);
  overflow: hidden; border: 3px solid var(--gold);
  box-shadow: 0 0 40px rgba(255,211,110,0.5);
  transition: all 0.8s ease;
}
.evo-card img { width: 100%; height: 100%; object-fit: cover; }
.evo-arrow {
  font-size: 2rem; color: var(--gold);
  animation: evoArrow 1s ease-in-out infinite;
}
@keyframes evoArrow { 0%, 100% { transform: translateX(0); opacity: 0.5; } 50% { transform: translateX(10px); opacity: 1; } }
.evo-sparkles {
  position: absolute; inset: 0; pointer-events: none;
  background: radial-gradient(ellipse at center, rgba(255,211,110,0.15) 0%, transparent 70%);
}

/* ===== FLOATING COMBAT TEXT ===== */
.float-text {
  position: fixed; font-family: var(--font-comic); font-weight: 700;
  pointer-events: none; z-index: 100;
  animation: floatUp 1.2s ease-out forwards;
  text-shadow: 0 2px 8px rgba(0,0,0,0.6);
}
.float-text.damage { color: var(--red); font-size: 1.6rem; }
.float-text.heal { color: var(--green); font-size: 1.4rem; }
.float-text.super { color: #fbbf24; font-size: 2rem; animation: superFloat 1.4s ease-out forwards; }
.float-text.resist { color: var(--muted); font-size: 1.1rem; }
.float-text.status { color: var(--purple); font-size: 1.1rem; }
.float-text.ko { color: var(--red); font-size: 2.5rem; animation: koFloat 1.5s ease-out forwards; }
.float-text.combo { color: var(--orange); font-size: 1.8rem; }
.float-text.xp { color: var(--cyan); font-size: 1rem; animation: xpOrb 1.5s ease-in forwards; }
.float-text.immune { color: #94a3b8; font-size: 1.3rem; }
.float-text.guard-text { color: var(--blue); font-size: 1.3rem; }
@keyframes floatUp {
  0% { opacity: 1; transform: translateY(0) scale(1); }
  30% { transform: translateY(-20px) scale(1.2); }
  100% { opacity: 0; transform: translateY(-60px) scale(0.8); }
}
@keyframes superFloat {
  0% { opacity: 1; transform: translateY(0) scale(0.5) rotate(-5deg); }
  20% { transform: translateY(-10px) scale(1.5) rotate(5deg); }
  40% { transform: translateY(-20px) scale(1.2) rotate(-3deg); }
  100% { opacity: 0; transform: translateY(-80px) scale(0.6); }
}
@keyframes koFloat {
  0% { opacity: 0; transform: scale(0) rotate(-10deg); }
  30% { opacity: 1; transform: scale(1.5) rotate(5deg); }
  60% { transform: scale(1.1) rotate(-2deg); }
  100% { opacity: 0; transform: scale(0.5) translateY(-40px); }
}
@keyframes xpOrb {
  0% { opacity: 1; transform: translateY(0) scale(1); }
  100% { opacity: 0; transform: translateY(-120px) scale(0.3); }
}

/* ===== BATTLE EVENT BANNER ===== */
.battle-event-banner {
  position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0);
  padding: 16px 40px; background: var(--panel-strong); backdrop-filter: var(--glass-blur);
  border: 2px solid var(--gold-dark); border-radius: var(--radius-lg);
  z-index: 200; text-align: center; opacity: 0;
  transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
}
.battle-event-banner.show { opacity: 1; transform: translate(-50%, -50%) scale(1); }
.battle-event-banner .event-title { font-family: var(--font-comic); font-size: 1.3rem; color: var(--gold); }
.battle-event-banner .event-desc { font-size: 0.85rem; color: var(--text-secondary); margin-top: 4px; }

/* ===== VFX ANIMATIONS ===== */
/* Screen shake */
.shake { animation: screenShake 0.4s ease-out; }
@keyframes screenShake {
  0%, 100% { transform: translateX(0); }
  20% { transform: translateX(-6px) rotate(-0.5deg); }
  40% { transform: translateX(5px) rotate(0.5deg); }
  60% { transform: translateX(-3px); } 80% { transform: translateX(2px); }
}
.heavy-shake { animation: heavyShake 0.6s ease-out; }
@keyframes heavyShake {
  0%, 100% { transform: translate(0); }
  10% { transform: translate(-8px, 4px) rotate(-1deg); }
  20% { transform: translate(7px, -3px) rotate(1deg); }
  30% { transform: translate(-6px, 2px) rotate(-0.5deg); }
  40% { transform: translate(5px, -1px) rotate(0.5deg); }
  50% { transform: translate(-3px, 1px); }
  60% { transform: translate(2px, -1px); }
}

/* Attack animations */
.attack-lunge-up { animation: lungUp 0.5s cubic-bezier(0.4, 0, 0.2, 1); }
@keyframes lungUp {
  0% { transform: translateY(0) scale(1); }
  25% { transform: translateY(-30px) scale(1.08); }
  50% { transform: translateY(-25px) scale(1.05); }
  100% { transform: translateY(0) scale(1); }
}
.attack-lunge-down { animation: lungDown 0.5s cubic-bezier(0.4, 0, 0.2, 1); }
@keyframes lungDown {
  0% { transform: translateY(0) scale(1); }
  25% { transform: translateY(30px) scale(1.08); }
  50% { transform: translateY(25px) scale(1.05); }
  100% { transform: translateY(0) scale(1); }
}

/* Hit effects */
.hit-flash { animation: hitFlash 0.35s ease-out; }
@keyframes hitFlash {
  0% { filter: brightness(1); transform: scale(1); }
  15% { filter: brightness(3) saturate(0); transform: scale(1.05); }
  30% { filter: brightness(0.8); transform: scale(0.97) translateX(-3px); }
  50% { filter: brightness(1.5); transform: scale(1.02) translateX(3px); }
  100% { filter: brightness(1); transform: scale(1); }
}
.super-hit { animation: superHit 0.5s ease-out; }
@keyframes superHit {
  0% { filter: brightness(1); transform: scale(1); }
  10% { filter: brightness(4) saturate(2); transform: scale(1.12); }
  25% { filter: brightness(0.6); transform: scale(0.92) rotate(-3deg); }
  40% { filter: brightness(2); transform: scale(1.06) rotate(2deg); }
  60% { filter: brightness(0.9); transform: scale(0.98) rotate(-1deg); }
  100% { filter: brightness(1); transform: scale(1) rotate(0); }
}
.resist-hit { animation: resistHit 0.4s ease-out; }
@keyframes resistHit {
  0% { filter: brightness(1); }
  30% { filter: brightness(1.2) saturate(0.5); transform: translateX(2px); }
  100% { filter: brightness(1); transform: translateX(0); }
}

/* KO animation */
.ko-shatter { animation: koShatter 1s ease-out forwards; }
@keyframes koShatter {
  0% { transform: scale(1); opacity: 1; filter: brightness(1); }
  15% { transform: scale(1.1); filter: brightness(3); }
  30% { transform: scale(1.05) rotate(2deg); filter: brightness(2); }
  50% { transform: scale(0.9) rotate(-3deg); opacity: 0.8; }
  70% { transform: scale(0.6) rotate(5deg); opacity: 0.5; filter: brightness(0.5); }
  100% { transform: scale(0) rotate(15deg); opacity: 0; }
}

/* Heal glow */
.heal-glow { animation: healGlow 0.8s ease-out; }
@keyframes healGlow {
  0% { box-shadow: 0 0 0 rgba(125,255,180,0); }
  30% { box-shadow: 0 0 30px rgba(125,255,180,0.6), inset 0 0 20px rgba(125,255,180,0.2); }
  100% { box-shadow: 0 0 0 rgba(125,255,180,0); }
}

/* Shield dome */
.shield-dome { animation: shieldDome 0.8s ease-out; }
@keyframes shieldDome {
  0% { box-shadow: 0 0 0 rgba(96,165,250,0); }
  30% { box-shadow: 0 0 25px rgba(96,165,250,0.6), inset 0 0 15px rgba(96,165,250,0.3); border-color: var(--blue); }
  100% { box-shadow: 0 0 0 rgba(96,165,250,0); }
}

/* Guard stance */
.guard-stance { animation: guardStance 0.6s ease-out; }
@keyframes guardStance {
  0% { transform: scale(1); }
  30% { transform: scale(1.05); box-shadow: 0 0 20px rgba(96,165,250,0.5); }
  100% { transform: scale(1); }
}

/* Burn DOT tick */
.burn-tick { animation: burnTick 0.5s ease-out; }
@keyframes burnTick {
  0% { box-shadow: 0 0 0 rgba(239,68,68,0); }
  30% { box-shadow: 0 0 15px rgba(239,68,68,0.5), inset 0 0 10px rgba(239,68,68,0.2); }
  100% { box-shadow: 0 0 0 rgba(239,68,68,0); }
}

/* Entrance animations for battle cards */
.card-enter-hero { animation: cardEnterHero 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) both; }
@keyframes cardEnterHero {
  0% { opacity: 0; transform: translateY(60px) scale(0.8) rotate(5deg); }
  100% { opacity: 1; transform: translateY(0) scale(1) rotate(0); }
}
.card-enter-enemy { animation: cardEnterEnemy 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) both; }
@keyframes cardEnterEnemy {
  0% { opacity: 0; transform: translateY(-60px) scale(0.8) rotate(-5deg); }
  100% { opacity: 1; transform: translateY(0) scale(1) rotate(0); }
}

/* Round transition pulse */
.round-pulse { animation: roundPulse 0.6s ease-out; }
@keyframes roundPulse {
  0% { transform: scale(1); } 30% { transform: scale(1.15); color: #fff; }
  100% { transform: scale(1); }
}

/* Confetti particle */
.confetti {
  position: fixed; width: 8px; height: 8px; z-index: 600; pointer-events: none;
  animation: confettiFall linear forwards;
}
@keyframes confettiFall {
  0% { opacity: 1; transform: translateY(0) rotate(0deg); }
  100% { opacity: 0; transform: translateY(100vh) rotate(720deg); }
}

/* XP orb */
.xp-orb {
  position: fixed; width: 10px; height: 10px; border-radius: 50%;
  background: radial-gradient(circle, var(--cyan), var(--purple));
  box-shadow: 0 0 8px var(--cyan); z-index: 150; pointer-events: none;
}

/* Screen flash */
.screen-flash {
  position: fixed; inset: 0; z-index: 400; pointer-events: none;
  animation: screenFlash 0.3s ease-out forwards;
}
@keyframes screenFlash { 0% { opacity: 0.6; } 100% { opacity: 0; } }

/* Element burst particles */
.element-particle {
  position: fixed; width: 6px; height: 6px; border-radius: 50%;
  pointer-events: none; z-index: 150;
  animation: elementBurst 0.8s ease-out forwards;
}
@keyframes elementBurst {
  0% { opacity: 1; transform: translate(0, 0) scale(1); }
  100% { opacity: 0; transform: translate(var(--dx), var(--dy)) scale(0); }
}

/* ===== BATTLE LOG ===== */
.battle-log {
  position: fixed; bottom: 0; right: 0; width: 260px; max-height: 200px;
  overflow-y: auto; padding: 8px; background: rgba(0,0,0,0.5);
  backdrop-filter: blur(8px); border-radius: var(--radius-md) 0 0 0;
  z-index: 50; font-size: 0.65rem; color: var(--muted); display: none;
}
.battle-log.visible { display: block; }
.log-entry { padding: 2px 0; border-bottom: 1px solid rgba(255,255,255,0.05); }

/* ===== RESPONSIVE ===== */
@media (max-width: 480px) {
  .battle-card { padding: 6px; }
  .card-portrait { height: 45px; }
  .action-panel { padding: 8px; }
  .battle-log { display: none !important; }
  .turn-order-bar { display: none; }
}
  </style>
</head>
<body>

<!-- Background -->
<!-- Navigation Bar -->
<nav class="nav-bar">
  <button class="back-btn" onclick="goToHub()">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M19 12H5"/><path d="M12 19l-7-7 7-7"/></svg>
    Hub
  </button>
  <div class="nav-title">William's World</div>
  <div class="nav-streak" id="nav-streak">üî• <span id="streak-display">0</span> day streak</div>
</nav>

<div id="battle-bg"></div>

<!-- VFX Overlay -->
<div id="vfx-overlay"></div>

<!-- Floating particles -->
<div id="particles"></div>

<!-- SCREEN 1: Zone Select + Scout -->
<div id="scout-screen" class="screen active">
  <div class="zone-title" id="zone-title">Launch Meadow</div>
  <div class="zone-subtitle" id="zone-subtitle">A bright meadow where young adventurers take their first steps.</div>
  <div class="zone-badge" id="zone-modifier">
    <span>‚òÄÔ∏è</span>
    <span id="modifier-text">Sunny Day: +10% Light moves</span>
  </div>
  <div class="xp-display" id="xp-display">
    <div class="rank-badges" id="rank-badges"></div>
    <div class="xp-label" id="xp-label">Team XP: 0 / 100</div>
    <div class="xp-bar-outer"><div class="xp-bar-inner" id="xp-bar" style="width:0%"></div></div>
  </div>
  <div class="zone-selector" id="zone-selector"></div>
  <button class="scout-btn" id="scout-btn" onclick="startEncounter()">
    <span class="shimmer"></span>
    Scout for Trouble
  </button>
</div>

<!-- SCREEN 2: Card Draw / Reveal -->
<div id="draw-screen" class="screen">
  <div class="draw-title" id="draw-title">Drawing Enemies...</div>
  <div style="display:flex; align-items:center; gap: clamp(16px, 4vw, 32px); justify-content:center;">
    <div class="draw-area" id="draw-area"></div>
    <div class="enemy-deck" id="enemy-deck">
      <div class="deck-glow"></div>
      <div class="deck-stack"></div>
      <div class="deck-stack"></div>
      <div class="deck-stack"></div>
    </div>
  </div>
  <button class="scout-btn" id="start-battle-btn" style="display:none;" onclick="startBattle()">
    <span class="shimmer"></span>
    Begin Battle!
  </button>
</div>

<!-- SCREEN 3: Battle Field -->
<div id="battle-screen" class="screen">
  <div class="battle-hud">
    <div class="hud-left">
      <div class="round-counter" id="round-counter">Round 1</div>
      <div class="combo-meter" id="combo-meter">Combo x2</div>
    </div>
    <div class="turn-order-bar" id="turn-order-bar"></div>
    <div class="hud-right">
      <div class="phase-indicator" id="phase-indicator">Your Turn</div>
    </div>
  </div>

  <div class="battle-field">
    <div class="card-row" id="enemy-row"></div>
    <div class="lane-divider">
      <div class="lane-line"></div>
      <div class="lane-vs">VS</div>
      <div class="lane-line"></div>
    </div>
    <div class="card-row" id="hero-row"></div>
  </div>

  <div class="action-panel" id="action-panel">
    <div class="action-label" id="action-label">Select a hero to see their moves</div>
    <div class="action-buttons" id="action-buttons"></div>
  </div>
</div>

<!-- SCREEN 4: Result -->
<div id="result-screen" class="screen">
  <div class="result-title" id="result-title">Victory!</div>
  <div class="result-subtitle" id="result-subtitle"></div>
  <div class="reward-list" id="reward-list"></div>
  <button class="result-btn" onclick="resetBattle()">Battle Again</button>
</div>

<!-- SCREEN 5: Evolution -->
<div id="evolution-screen" class="screen">
  <div class="evo-sparkles"></div>
  <div class="evo-title" id="evo-title">EVOLUTION!</div>
  <div class="evo-container" id="evo-container"></div>
  <button class="scout-btn" id="evo-continue-btn" onclick="continueAfterEvolution()">
    <span class="shimmer"></span>
    Continue
  </button>
</div>

<!-- Battle Event Banner -->
<div class="battle-event-banner" id="battle-event-banner">
  <div class="event-title" id="event-title"></div>
  <div class="event-desc" id="event-desc"></div>
</div>

<!-- Battle Log -->
<div class="battle-log" id="battle-log"></div>

<script>
/* ================================================================
   WILLIAM'S WORLD ‚Äî BATTLE ENGINE v2.0
   Full Pok√©mon-cartoon animation system + Hero Leveling
   ================================================================ */

// ===== IMAGE URLS =====
const IMG = {
  william: [
    'https://files.manuscdn.com/user_upload_by_module/session_file/310519663346319809/tEYVeMWBLXdYcYTz.PNG',
    'https://files.manuscdn.com/user_upload_by_module/session_file/310519663346319809/tEYVeMWBLXdYcYTz.PNG',
    'https://files.manuscdn.com/user_upload_by_module/session_file/310519663346319809/tEYVeMWBLXdYcYTz.PNG',
  ],
  ember: [
    'https://files.manuscdn.com/user_upload_by_module/session_file/310519663346319809/hZBbuiyBIVYpcHwf.png',
    'https://files.manuscdn.com/user_upload_by_module/session_file/310519663346319809/qyjmQYVaZLywJLZl.png',
    'https://files.manuscdn.com/user_upload_by_module/session_file/310519663346319809/dFZmBCCSzEvzVrvP.png',
  ],
  sprite: [
    'https://files.manuscdn.com/user_upload_by_module/session_file/310519663346319809/LkCpwgzZkxKPhmgY.png',
    'https://files.manuscdn.com/user_upload_by_module/session_file/310519663346319809/ZTnIPBHBEafHuoYI.png',
    'https://files.manuscdn.com/user_upload_by_module/session_file/310519663346319809/gzcRlQAuRbHJOZER.png',
  ],
};

const ZONE_BG = {
  'launch-meadow': 'https://files.manuscdn.com/user_upload_by_module/session_file/310519663346319809/ViufidrtINIybyJL.png',
  'homework-hills': 'https://files.manuscdn.com/user_upload_by_module/session_file/310519663346319809/jsTYrQVFsbdfOynZ.png',
  'backpack-bastion': 'https://files.manuscdn.com/user_upload_by_module/session_file/310519663346319809/StAvzZIzdEKQxebb.png',
  'focus-forest': 'https://files.manuscdn.com/user_upload_by_module/session_file/310519663346319809/WeOgAUHJzaIqkKqA.png',
};

// ===== LEVELING SYSTEM =====
const RANK_NAMES = ['Starter', 'Expert', 'Legendary'];
const RANK_XP = [0, 100, 300]; // XP needed to reach each rank
const RANK_STAT_MULTIPLIER = [1.0, 1.25, 1.6];
const RANK_TITLES = {
  william: ['Young Hero', 'Battle Commander', 'World Champion'],
  ember: ['Fire Cub', 'Flame Warrior', 'Inferno Lord'],
  sprite: ['Leaf Sprite', 'Nature Mage', 'Forest Goddess'],
};

// Persistent game state (saved to localStorage)
let gameState = loadGameState();

function loadGameState() {
  try {
    const saved = localStorage.getItem('ww-battle-state');
    if (saved) return JSON.parse(saved);
  } catch(e) {}
  return { teamXP: 0, teamRank: 0, wins: 0, totalBattles: 0 };
}
function saveGameState() {
  localStorage.setItem('ww-battle-state', JSON.stringify(gameState));
}

// ===== ZONE DATA =====
const ZONES = [
  { id: 'launch-meadow', name: 'Launch Meadow', desc: 'A bright meadow where young adventurers take their first steps. Enemies here are friendly but feisty!', modifier: '‚òÄÔ∏è Sunny Day: +10% Light moves', tier: 'T1', needStreak: 0 },
  { id: 'homework-hills', name: 'Homework Hills', desc: 'Rolling hills of books and pencils. The enemies here are tricky and love to debuff!', modifier: 'üìö Study Zone: +10% Shadow moves', tier: 'T2', needStreak: 3 },
  { id: 'backpack-bastion', name: 'Backpack Bastion', desc: 'A fortified outpost of supplies and gear. Tough enemies guard the path ahead.', modifier: 'üéí Gear Up: +10% Metal moves', tier: 'T3', needStreak: 5 },
  { id: 'focus-forest', name: 'Focus Forest', desc: 'A mystical forest of crystals and ancient trees. The strongest foes lurk in the shadows.', modifier: 'üîÆ Crystal Aura: +10% Ice moves', tier: 'T4', needStreak: 10 },
];

// ===== HUB INTEGRATION: Read streak from main hub's localStorage =====
function getHubStreak() {
  try {
    const hubState = JSON.parse(localStorage.getItem('williams_world_embed_state_v1'));
    if (hubState) return hubState.maxStreak ?? hubState.streak ?? 0;
  } catch(e) {}
  return 0;
}

function isZoneUnlocked(zone) {
  return getHubStreak() >= zone.needStreak;
}

// Read zone from URL params (from hub navigation)
function getZoneFromURL() {
  const params = new URLSearchParams(window.location.search);
  const zoneParam = params.get('zone');
  if (zoneParam) {
    const found = ZONES.find(z => z.id === zoneParam || z.id === zoneParam.replace(/\s/g, '-'));
    if (found && isZoneUnlocked(found)) return found;
  }
  return null;
}

// ===== HERO DATA (with rank-based evolution) =====
function getHeroImg(heroId) { return IMG[heroId][gameState.teamRank] || IMG[heroId][0]; }
function getHeroTitle(heroId) { return RANK_TITLES[heroId][gameState.teamRank] || RANK_TITLES[heroId][0]; }

const HERO_BASE = [
  {
    id: 'william', name: 'William', element: 'NEUTRAL',
    baseStats: { hp: 120, atk: 14, def: 12, spd: 12 },
    moves: [
      { name: 'Tiger Strike', type: 'damage', element: 'NEUTRAL', cooldown: 0, maxCd: 1, power: 20, desc: 'A fast strike that always hits.', keywords: ['Damage'], target: 'single_enemy' },
      { name: 'Team Call', type: 'buff', element: 'NEUTRAL', cooldown: 0, maxCd: 4, power: 0, desc: 'Rally: Focus (+15% ATK) for 2 turns.', keywords: ['Buff'], effect: 'focus', target: 'all_allies' },
      { name: 'Brave Guard', type: 'shield', element: 'NEUTRAL', cooldown: 0, maxCd: 3, power: 25, desc: 'Shield an ally for 2 turns.', keywords: ['Shield'], target: 'ally' },
    ],
    rankMoves: {
      1: { name: 'Courage Blast', type: 'damage', element: 'LIGHT', cooldown: 0, maxCd: 3, power: 35, desc: 'A powerful light blast. May Stun.', keywords: ['Damage', 'Stun'], statusChance: 0.2, statusType: 'shock', target: 'single_enemy' },
      2: { name: 'Hero\'s Resolve', type: 'buff', element: 'LIGHT', cooldown: 0, maxCd: 5, power: 40, desc: 'Heals team + Focus for 3 turns.', keywords: ['Heal', 'Buff'], effect: 'focus', target: 'all_allies' },
    }
  },
  {
    id: 'ember', name: 'Ember', element: 'FIRE',
    baseStats: { hp: 110, atk: 16, def: 10, spd: 12 },
    moves: [
      { name: 'Ember Bite', type: 'damage', element: 'FIRE', cooldown: 0, maxCd: 2, power: 24, desc: 'A fiery bite that may Burn (25%).', keywords: ['Damage', 'Burn'], statusChance: 0.25, statusType: 'burn', target: 'single_enemy' },
      { name: 'Heat Up', type: 'buff', element: 'FIRE', cooldown: 0, maxCd: 4, power: 0, desc: 'Gains Focus (+15% ATK) for 2 turns.', keywords: ['Buff'], effect: 'focus', target: 'self' },
      { name: 'Flame Dash', type: 'damage', element: 'FIRE', cooldown: 0, maxCd: 3, power: 30, desc: 'Dash through for medium damage.', keywords: ['Damage'], target: 'single_enemy' },
    ],
    rankMoves: {
      1: { name: 'Inferno Claw', type: 'damage', element: 'FIRE', cooldown: 0, maxCd: 3, power: 40, desc: 'Massive fire claw. Burns (40%).', keywords: ['Damage', 'Burn'], statusChance: 0.4, statusType: 'burn', target: 'single_enemy' },
      2: { name: 'Blaze Storm', type: 'damage', element: 'FIRE', cooldown: 0, maxCd: 5, power: 50, desc: 'Fire storm hits ALL enemies.', keywords: ['Damage', 'Burn'], statusChance: 0.3, statusType: 'burn', target: 'all_enemies' },
    }
  },
  {
    id: 'sprite', name: 'Sprite', element: 'LIGHT',
    baseStats: { hp: 95, atk: 10, def: 10, spd: 15 },
    moves: [
      { name: 'Glow Heal', type: 'heal', element: 'LIGHT', cooldown: 0, maxCd: 3, power: 30, desc: 'Heal one ally.', keywords: ['Heal'], target: 'ally' },
      { name: 'Sparkle Shield', type: 'shield', element: 'LIGHT', cooldown: 0, maxCd: 4, power: 20, desc: 'Shield one ally for 2 turns.', keywords: ['Shield'], target: 'ally' },
      { name: 'Dazzle', type: 'control', element: 'LIGHT', cooldown: 0, maxCd: 5, power: 12, desc: 'May Blind all enemies (25%).', keywords: ['Blind'], statusChance: 0.25, statusType: 'blind', target: 'all_enemies' },
    ],
    rankMoves: {
      1: { name: 'Nature\'s Embrace', type: 'heal', element: 'GRASS', cooldown: 0, maxCd: 4, power: 45, desc: 'Heals ALL allies.', keywords: ['Heal'], target: 'all_allies' },
      2: { name: 'Radiant Bloom', type: 'damage', element: 'LIGHT', cooldown: 0, maxCd: 5, power: 45, desc: 'Light blast + heal team 20HP.', keywords: ['Damage', 'Heal'], target: 'all_enemies' },
    }
  },
];

function buildHeroes() {
  const rank = gameState.teamRank;
  const multi = RANK_STAT_MULTIPLIER[rank];
  return HERO_BASE.map(h => {
    const moves = [...h.moves];
    // Add rank-unlocked moves
    for (let r = 1; r <= rank; r++) {
      if (h.rankMoves[r]) moves.push(h.rankMoves[r]);
    }
    return {
      ...h,
      title: getHeroTitle(h.id),
      img: getHeroImg(h.id),
      rank: rank,
      stats: {
        hp: Math.floor(h.baseStats.hp * multi),
        atk: Math.floor(h.baseStats.atk * multi),
        def: Math.floor(h.baseStats.def * multi),
        spd: Math.floor(h.baseStats.spd * multi),
      },
      moves: moves.slice(0, 4), // Max 4 moves
    };
  });
}

// ===== ENEMY IMAGE MAP =====
const ENEMY_IMAGES = {
  'dandelion-dagger': 'https://files.manuscdn.com/user_upload_by_module/session_file/310519663346319809/MjEOCsNbbUdnqdcu.png',
  'mudkip-bandit': 'https://files.manuscdn.com/user_upload_by_module/session_file/310519663346319809/tLNXpyLjyRfjDZYS.png',
  'pebble-pouncer': 'https://files.manuscdn.com/user_upload_by_module/session_file/310519663346319809/xbnxDvagIJGKUiqc.png',
  'sunblink-moth': 'https://files.manuscdn.com/user_upload_by_module/session_file/310519663346319809/spHADFiiaNOgjDKJ.png',
  'thorny-sneak': 'https://files.manuscdn.com/user_upload_by_module/session_file/310519663346319809/quAAiUfmMcbNKMQL.png',
  'scorchling': 'https://files.manuscdn.com/user_upload_by_module/session_file/310519663346319809/aIjpCfmeRuUVLfTe.png',
  'windwink-imp': 'https://files.manuscdn.com/user_upload_by_module/session_file/310519663346319809/vIWIfJAJLOSYoJFg.png',
  'spark-dustling': 'https://files.manuscdn.com/user_upload_by_module/session_file/310519663346319809/BKOqdcygUptKNRmX.png',
  'nightleaf-snatcher': 'https://files.manuscdn.com/user_upload_by_module/session_file/310519663346319809/QXqZjdUKHULGJgBn.png',
  'slimecap-trickster': 'https://files.manuscdn.com/user_upload_by_module/session_file/310519663346319809/tuGyktQgGHDEzRmf.png',
  'eraser-wraith': 'https://files.manuscdn.com/user_upload_by_module/session_file/310519663346319809/eCQdyipNHgnsKnrW.png',
  'paper-cut-pirate': 'https://files.manuscdn.com/user_upload_by_module/session_file/310519663346319809/kbYiGZockTSwemJa.png',
  'inkblob-gremlin': 'https://files.manuscdn.com/user_upload_by_module/session_file/310519663346319809/RfkgRAJkHsSDMojg.png',
  'quiz-golemlet': 'https://files.manuscdn.com/user_upload_by_module/session_file/310519663346319809/lIgqpnrTfmLjgFyY.png',
  'ruler-knight': 'https://files.manuscdn.com/user_upload_by_module/session_file/310519663346319809/hCaVNSFQrJIteJfg.png',
  'glue-gooper': 'https://files.manuscdn.com/user_upload_by_module/session_file/310519663346319809/sBuNBvjqaiSmWpDv.png',
  'chalk-phantom': 'https://files.manuscdn.com/user_upload_by_module/session_file/310519663346319809/SgBiLLGjFqrCRyYn.png',
  'zipper-viper': 'https://files.manuscdn.com/user_upload_by_module/session_file/310519663346319809/hSdrYvARVpLwpnQo.png',
  'buckle-brute': 'https://files.manuscdn.com/user_upload_by_module/session_file/310519663346319809/kkrwmnIPCoPMlDRF.png',
  'lint-lurker': 'https://files.manuscdn.com/user_upload_by_module/session_file/310519663346319809/syEqTGGozeWZPETm.png',
  'compass-spinner': 'https://files.manuscdn.com/user_upload_by_module/session_file/310519663346319809/eYwBfcdmnDxzwWGL.png',
  'thermos-titan': 'https://files.manuscdn.com/user_upload_by_module/session_file/310519663346319809/BQmuNOESStkNlogb.png',
  'crystal-crawler': 'https://files.manuscdn.com/user_upload_by_module/session_file/310519663346319809/evCbKkKXGvzvrTKF.png',
  'mindmoth': 'https://files.manuscdn.com/user_upload_by_module/session_file/310519663346319809/XargXwENKJLZyNHK.png',
  'root-warden': 'https://files.manuscdn.com/user_upload_by_module/session_file/310519663346319809/FQnlWcWaaVSauKOr.png',
  'prism-specter': 'https://files.manuscdn.com/user_upload_by_module/session_file/310519663346319809/eUesqWzUaKxQplhD.png',
  'void-weaver': 'https://files.manuscdn.com/user_upload_by_module/session_file/310519663346319809/pQLSQIHfWtEsxVJK.png'
};

// ===== ENEMY DATA =====
const ENEMIES_BY_ZONE = {
  'launch-meadow': [
    { id: 'dandelion-dagger', name: 'Dandelion Dagger', role: 'SKIRMISHER', element: 'GRASS', rarity: 'COMMON', emoji: 'üåº', moves: [{ name: 'Puff Slash', type: 'damage', power: 14, desc: 'Quick slash, may Blind.', keywords: ['Damage'], statusChance: 0.25, statusType: 'blind' },{ name: 'Seed Sprint', type: 'buff', power: 0, desc: 'Boosts speed.', keywords: ['Buff'], effect: 'focus' }]},
    { id: 'mudkip-bandit', name: 'Mudkip Bandit', role: 'BRUISER', element: 'WATER', rarity: 'COMMON', emoji: 'üíß', moves: [{ name: 'Mud Toss', type: 'damage', power: 14, desc: 'Toss mud; may Weaken.', keywords: ['Damage', 'Weaken'], statusChance: 0.2, statusType: 'weaken' },{ name: 'Puddle Guard', type: 'buff', power: 0, desc: 'Gains Guard.', keywords: ['Guard'], effect: 'guard' }]},
    { id: 'pebble-pouncer', name: 'Pebble Pouncer', role: 'SKIRMISHER', element: 'ROCK', rarity: 'COMMON', emoji: 'ü™®', moves: [{ name: 'Pounce', type: 'damage', power: 16, desc: 'Hits harder if target is slower.', keywords: ['Damage'] },{ name: 'Stone Skin', type: 'buff', power: 0, desc: 'Raises DEF.', keywords: ['Guard'], effect: 'guard' }]},
    { id: 'sunblink-moth', name: 'Sunblink Moth', role: 'CASTER', element: 'LIGHT', rarity: 'COMMON', emoji: 'ü¶ã', moves: [{ name: 'Glimmer Beam', type: 'damage', power: 12, desc: 'A simple light blast.', keywords: ['Damage'] },{ name: 'Dazzle', type: 'control', power: 8, desc: 'May Blind heroes.', keywords: ['Blind'], statusChance: 0.25, statusType: 'blind' }]},
    { id: 'thorny-sneak', name: 'Thorny Sneak', role: 'TRICKSTER', element: 'GRASS', rarity: 'UNCOMMON', emoji: 'üåø', moves: [{ name: 'Thorn Trap', type: 'control', power: 10, desc: 'Roots a hero.', keywords: ['Root'], statusChance: 1.0, statusType: 'root' },{ name: 'Sucker Vine', type: 'damage', power: 20, desc: 'Damage + lifesteal.', keywords: ['Damage', 'Heal'] }]},
    { id: 'scorchling', name: 'Scorchling', role: 'BRUISER', element: 'FIRE', rarity: 'UNCOMMON', emoji: 'üî•', moves: [{ name: 'Ember Bite', type: 'damage', power: 18, desc: 'Bites and may Burn.', keywords: ['Damage', 'Burn'], statusChance: 0.25, statusType: 'burn' },{ name: 'Heat Up', type: 'buff', power: 0, desc: 'Gains Focus.', keywords: ['Buff'], effect: 'focus' }]},
    { id: 'windwink-imp', name: 'Windwink Imp', role: 'SKIRMISHER', element: 'WIND', rarity: 'COMMON', emoji: 'üí®', moves: [{ name: 'Gust Jab', type: 'damage', power: 12, desc: 'Fast jab of wind.', keywords: ['Damage'] },{ name: 'Slipstream', type: 'buff', power: 0, desc: 'Boosts team speed.', keywords: ['Buff'], effect: 'focus' }]},
    { id: 'spark-dustling', name: 'Spark Dustling', role: 'CASTER', element: 'ELECTRIC', rarity: 'COMMON', emoji: '‚ö°', moves: [{ name: 'Static Pop', type: 'damage', power: 14, desc: 'May Shock.', keywords: ['Damage', 'Shock'], statusChance: 0.2, statusType: 'shock' },{ name: 'Charge', type: 'buff', power: 0, desc: 'Next hit does extra.', keywords: ['Buff'], effect: 'focus' }]},
    { id: 'nightleaf-snatcher', name: 'Nightleaf Snatcher', role: 'TRICKSTER', element: 'SHADOW', rarity: 'RARE', emoji: 'üåë', moves: [{ name: 'Swipe & Vanish', type: 'damage', power: 22, desc: 'Strikes and slows.', keywords: ['Damage', 'Debuff'], statusChance: 0.5, statusType: 'chill' },{ name: 'Shadow Cloak', type: 'buff', power: 0, desc: 'Dodges next attack.', keywords: ['Shield'], effect: 'guard' }]},
    { id: 'slimecap-trickster', name: 'Slimecap Trickster', role: 'SUPPORT', element: 'GRASS', rarity: 'ELITE', emoji: 'üçÑ', moves: [{ name: 'Spore Mist', type: 'debuff', power: 8, desc: 'Lowers hero ATK.', keywords: ['Debuff'], statusChance: 1.0, statusType: 'weaken' },{ name: 'Cap Bounce', type: 'damage', power: 18, desc: 'A bouncy slam.', keywords: ['Damage'] }]},
  ],
  'homework-hills': [
    { id: 'eraser-wraith', name: 'Eraser Wraith', role: 'TRICKSTER', element: 'SHADOW', rarity: 'COMMON', emoji: 'üëª', moves: [{ name: 'Erase Confidence', type: 'debuff', power: 10, desc: 'Weakens defense.', keywords: ['Weaken'], statusChance: 1.0, statusType: 'weaken' },{ name: 'Smudge Swipe', type: 'damage', power: 16, desc: 'Quick swipe.', keywords: ['Damage'] }]},
    { id: 'paper-cut-pirate', name: 'Paper Cut Pirate', role: 'SKIRMISHER', element: 'WIND', rarity: 'UNCOMMON', emoji: 'üè¥‚Äç‚ò†Ô∏è', moves: [{ name: 'Cutlass Cut', type: 'damage', power: 22, desc: 'Hits harder if debuffed.', keywords: ['Damage'] },{ name: 'Ruffle Gust', type: 'control', power: 8, desc: 'May Blind.', keywords: ['Blind'], statusChance: 0.25, statusType: 'blind' }]},
    { id: 'inkblob-gremlin', name: 'Inkblob Gremlin', role: 'CASTER', element: 'SHADOW', rarity: 'COMMON', emoji: 'üñãÔ∏è', moves: [{ name: 'Ink Spray', type: 'control', power: 8, desc: 'Blinds a hero.', keywords: ['Blind'], statusChance: 1.0, statusType: 'blind' },{ name: 'Blob Bolt', type: 'damage', power: 14, desc: 'Simple bolt.', keywords: ['Damage'] }]},
    { id: 'quiz-golemlet', name: 'Quiz Golemlet', role: 'TANK', element: 'ROCK', rarity: 'UNCOMMON', emoji: 'üóø', moves: [{ name: 'Pop Quiz Punch', type: 'damage', power: 18, desc: 'Solid punch.', keywords: ['Damage'] },{ name: 'Study Block', type: 'buff', power: 0, desc: 'Gains Guard.', keywords: ['Guard'], effect: 'guard' }]},
    { id: 'ruler-knight', name: 'Ruler Knight', role: 'TANK', element: 'METAL', rarity: 'RARE', emoji: 'üìè', moves: [{ name: 'Measure Strike', type: 'damage', power: 20, desc: 'Precise strike.', keywords: ['Damage'] },{ name: 'Straighten Up', type: 'buff', power: 0, desc: 'Guard + cleanse.', keywords: ['Guard', 'Cleanse'], effect: 'guard' }]},
    { id: 'glue-gooper', name: 'Glue Gooper', role: 'SUPPORT', element: 'WATER', rarity: 'COMMON', emoji: 'ü´†', moves: [{ name: 'Sticky Splash', type: 'control', power: 10, desc: 'Roots a hero.', keywords: ['Root'], statusChance: 1.0, statusType: 'root' },{ name: 'Goop Heal', type: 'heal', power: 15, desc: 'Heals an ally.', keywords: ['Heal'] }]},
    { id: 'chalk-phantom', name: 'Chalk Phantom', role: 'CASTER', element: 'LIGHT', rarity: 'ELITE', emoji: '‚ú®', moves: [{ name: 'Chalk Beam', type: 'damage', power: 24, desc: 'Powerful beam.', keywords: ['Damage'] },{ name: 'Dust Cloud', type: 'control', power: 8, desc: 'Blinds all heroes.', keywords: ['Blind'], statusChance: 0.3, statusType: 'blind' }]},
  ],
  'backpack-bastion': [
    { id: 'zipper-viper', name: 'Zipper Viper', role: 'SKIRMISHER', element: 'METAL', rarity: 'COMMON', emoji: 'üêç', moves: [{ name: 'Zip Strike', type: 'damage', power: 20, desc: 'Fast metal strike.', keywords: ['Damage'] },{ name: 'Coil Guard', type: 'buff', power: 0, desc: 'Gains Guard.', keywords: ['Guard'], effect: 'guard' }]},
    { id: 'buckle-brute', name: 'Buckle Brute', role: 'TANK', element: 'METAL', rarity: 'UNCOMMON', emoji: 'üî©', moves: [{ name: 'Buckle Bash', type: 'damage', power: 22, desc: 'Heavy bash.', keywords: ['Damage'] },{ name: 'Iron Wall', type: 'buff', power: 0, desc: 'Guard for team.', keywords: ['Guard'], effect: 'guard' }]},
    { id: 'lint-lurker', name: 'Lint Lurker', role: 'TRICKSTER', element: 'SHADOW', rarity: 'COMMON', emoji: 'üï∏Ô∏è', moves: [{ name: 'Lint Tangle', type: 'control', power: 10, desc: 'Roots a hero.', keywords: ['Root'], statusChance: 1.0, statusType: 'root' },{ name: 'Shadow Poke', type: 'damage', power: 18, desc: 'Sneaky poke.', keywords: ['Damage'] }]},
    { id: 'compass-spinner', name: 'Compass Spinner', role: 'CASTER', element: 'WIND', rarity: 'RARE', emoji: 'üß≠', moves: [{ name: 'Spin Blast', type: 'damage', power: 24, desc: 'Whirling blast.', keywords: ['Damage'] },{ name: 'True North', type: 'buff', power: 0, desc: 'Focus for team.', keywords: ['Buff'], effect: 'focus' }]},
    { id: 'thermos-titan', name: 'Thermos Titan', role: 'TANK', element: 'FIRE', rarity: 'ELITE', emoji: 'ü´ó', moves: [{ name: 'Steam Blast', type: 'damage', power: 26, desc: 'Burns and damages.', keywords: ['Damage', 'Burn'], statusChance: 0.35, statusType: 'burn' },{ name: 'Heat Shield', type: 'buff', power: 0, desc: 'Guard + Focus.', keywords: ['Guard', 'Buff'], effect: 'guard' }]},
  ],
  'focus-forest': [
    { id: 'crystal-crawler', name: 'Crystal Crawler', role: 'TANK', element: 'ICE', rarity: 'COMMON', emoji: 'üíé', moves: [{ name: 'Frost Bite', type: 'damage', power: 24, desc: 'Icy bite, may Chill.', keywords: ['Damage', 'Chill'], statusChance: 0.3, statusType: 'chill' },{ name: 'Crystal Shell', type: 'buff', power: 0, desc: 'Strong Guard.', keywords: ['Guard'], effect: 'guard' }]},
    { id: 'mindmoth', name: 'Mindmoth', role: 'CASTER', element: 'SHADOW', rarity: 'UNCOMMON', emoji: 'ü¶á', moves: [{ name: 'Psychic Pulse', type: 'damage', power: 22, desc: 'Mental attack.', keywords: ['Damage'] },{ name: 'Confuse Ray', type: 'control', power: 8, desc: 'May Shock.', keywords: ['Shock'], statusChance: 0.35, statusType: 'shock' }]},
    { id: 'root-warden', name: 'Root Warden', role: 'TANK', element: 'GRASS', rarity: 'COMMON', emoji: 'üå≥', moves: [{ name: 'Root Slam', type: 'damage', power: 22, desc: 'Roots and slams.', keywords: ['Damage', 'Root'], statusChance: 0.3, statusType: 'root' },{ name: 'Nature Guard', type: 'buff', power: 0, desc: 'Guard for team.', keywords: ['Guard'], effect: 'guard' }]},
    { id: 'prism-specter', name: 'Prism Specter', role: 'CASTER', element: 'LIGHT', rarity: 'RARE', emoji: 'üåà', moves: [{ name: 'Prism Beam', type: 'damage', power: 28, desc: 'Powerful light beam.', keywords: ['Damage'] },{ name: 'Refract', type: 'buff', power: 0, desc: 'Focus + Shield.', keywords: ['Buff', 'Shield'], effect: 'focus' }]},
    { id: 'void-weaver', name: 'Void Weaver', role: 'TRICKSTER', element: 'SHADOW', rarity: 'ELITE', emoji: 'üï∑Ô∏è', moves: [{ name: 'Void Rend', type: 'damage', power: 30, desc: 'Devastating shadow strike.', keywords: ['Damage', 'Weaken'], statusChance: 0.4, statusType: 'weaken' },{ name: 'Dark Veil', type: 'buff', power: 0, desc: 'Dodge + Focus.', keywords: ['Shield', 'Buff'], effect: 'guard' }]},
  ],
};

// Tier stat scaling
const TIER_STATS = {
  T1: { COMMON: {hp:60,atk:10,def:8,spd:10}, UNCOMMON: {hp:70,atk:12,def:9,spd:11}, RARE: {hp:80,atk:14,def:10,spd:12}, ELITE: {hp:95,atk:16,def:12,spd:12} },
  T2: { COMMON: {hp:85,atk:14,def:11,spd:12}, UNCOMMON: {hp:95,atk:16,def:12,spd:13}, RARE: {hp:110,atk:18,def:13,spd:14}, ELITE: {hp:130,atk:20,def:15,spd:14} },
  T3: { COMMON: {hp:120,atk:18,def:15,spd:14}, UNCOMMON: {hp:135,atk:20,def:16,spd:15}, RARE: {hp:155,atk:22,def:18,spd:16}, ELITE: {hp:185,atk:24,def:20,spd:16} },
  T4: { COMMON: {hp:165,atk:22,def:18,spd:16}, UNCOMMON: {hp:185,atk:24,def:20,spd:17}, RARE: {hp:210,atk:26,def:22,spd:18}, ELITE: {hp:250,atk:28,def:24,spd:18} },
};

const ELEMENT_COLORS = {
  FIRE: 'var(--type-fire)', WATER: 'var(--type-water)', GRASS: 'var(--type-grass)',
  ELECTRIC: 'var(--type-electric)', ICE: 'var(--type-ice)', ROCK: 'var(--type-rock)',
  SHADOW: 'var(--type-shadow)', LIGHT: 'var(--type-light)', WIND: 'var(--type-wind)',
  METAL: 'var(--type-metal)', NEUTRAL: 'var(--type-neutral)',
};
const ELEMENT_RAW_COLORS = {
  FIRE: '#ef4444', WATER: '#3b82f6', GRASS: '#22c55e', ELECTRIC: '#eab308',
  ICE: '#06b6d4', ROCK: '#78716c', SHADOW: '#6366f1', LIGHT: '#fbbf24',
  WIND: '#14b8a6', METAL: '#94a3b8', NEUTRAL: '#a8a29e',
};
const RARITY_COLORS = {
  COMMON: 'var(--rarity-common)', UNCOMMON: 'var(--rarity-uncommon)',
  RARE: 'var(--rarity-rare)', ELITE: 'var(--rarity-elite)',
};
const TYPE_CHART = {
  FIRE: { GRASS: 2, ICE: 2, WATER: 0.5, ROCK: 0.5, METAL: 0.5 },
  WATER: { FIRE: 2, ROCK: 2, GRASS: 0.5, ELECTRIC: 0.5 },
  GRASS: { WATER: 2, ROCK: 2, FIRE: 0.5, ICE: 0.5, SHADOW: 0.5, WIND: 0.5 },
  ELECTRIC: { WATER: 2, WIND: 2, METAL: 2, ELECTRIC: 0.5 },
  ICE: { GRASS: 2, ROCK: 2, WIND: 2, FIRE: 0.5, ICE: 0.5, METAL: 0.5 },
  ROCK: { FIRE: 2, ICE: 2, ELECTRIC: 0.5, WATER: 0.5, WIND: 0.5 },
  SHADOW: { LIGHT: 2, SHADOW: 0.5 },
  LIGHT: { SHADOW: 2, LIGHT: 0.5 },
  WIND: { GRASS: 2, ELECTRIC: 0.5, ICE: 0.5 },
  METAL: { FIRE: 2, ICE: 2, ROCK: 2, ELECTRIC: 0.5, METAL: 0.5 },
  NEUTRAL: {},
};

const BATTLE_EVENTS = [
  { title: 'üå´Ô∏è Fog Rolls In!', desc: 'Accuracy -10% for 2 rounds.' },
  { title: 'üí∞ Treasure Chest!', desc: 'Break it for bonus XP!' },
  { title: '‚ö†Ô∏è Enemy Reinforcements?', desc: 'Nope ‚Äî false alarm! üòÖ' },
  { title: 'üåü Star Alignment!', desc: 'All moves get +5 power this round!' },
  { title: 'üí® Tailwind!', desc: 'Your team acts first this round!' },
  { title: 'üåßÔ∏è Rain Starts!', desc: 'Water moves +15% this round.' },
];

// ===== GAME STATE =====
let currentZone = ZONES[0];
let drawnEnemies = [];
let heroParty = [];
let enemyParty = [];
let selectedHeroIdx = -1;
let heroActions = [null, null, null];
let currentRound = 1;
let comboCount = 0;
let battleLog = [];
let battlePhase = 'player';
let lastEnemyTrio = null;
let pendingEvolutions = [];

// ===== VFX SYSTEM =====
function spawnElementParticles(element, x, y, count = 12) {
  const color = ELEMENT_RAW_COLORS[element] || '#ffd36e';
  for (let i = 0; i < count; i++) {
    const p = document.createElement('div');
    p.className = 'element-particle';
    p.style.background = color;
    p.style.left = x + 'px';
    p.style.top = y + 'px';
    const angle = (Math.PI * 2 / count) * i + (Math.random() * 0.5);
    const dist = 30 + Math.random() * 50;
    p.style.setProperty('--dx', Math.cos(angle) * dist + 'px');
    p.style.setProperty('--dy', Math.sin(angle) * dist + 'px');
    p.style.animationDuration = (0.5 + Math.random() * 0.4) + 's';
    document.getElementById('vfx-overlay').appendChild(p);
    setTimeout(() => p.remove(), 1000);
  }
}

function screenFlash(color = 'white') {
  const flash = document.createElement('div');
  flash.className = 'screen-flash';
  flash.style.background = color;
  document.body.appendChild(flash);
  setTimeout(() => flash.remove(), 400);
}

function spawnConfetti(count = 50) {
  const colors = ['#ffd36e', '#ef4444', '#3b82f6', '#22c55e', '#a78bfa', '#ff9d5c', '#06b6d4'];
  for (let i = 0; i < count; i++) {
    const c = document.createElement('div');
    c.className = 'confetti';
    c.style.left = Math.random() * 100 + 'vw';
    c.style.top = '-10px';
    c.style.background = colors[Math.floor(Math.random() * colors.length)];
    c.style.borderRadius = Math.random() > 0.5 ? '50%' : '2px';
    c.style.width = (4 + Math.random() * 8) + 'px';
    c.style.height = (4 + Math.random() * 8) + 'px';
    c.style.animationDuration = (2 + Math.random() * 3) + 's';
    c.style.animationDelay = Math.random() * 1 + 's';
    document.body.appendChild(c);
    setTimeout(() => c.remove(), 6000);
  }
}

function spawnXPOrbs(fromEl, count = 5) {
  if (!fromEl) return;
  const rect = fromEl.getBoundingClientRect();
  for (let i = 0; i < count; i++) {
    const orb = document.createElement('div');
    orb.className = 'xp-orb';
    orb.style.left = (rect.left + rect.width / 2 + (Math.random() * 30 - 15)) + 'px';
    orb.style.top = (rect.top + rect.height / 2) + 'px';
    orb.style.transition = `all ${0.8 + Math.random() * 0.5}s cubic-bezier(0.4, 0, 0.2, 1)`;
    document.body.appendChild(orb);
    setTimeout(() => {
      orb.style.top = '-20px';
      orb.style.left = '50vw';
      orb.style.opacity = '0';
    }, 50 + i * 100);
    setTimeout(() => orb.remove(), 2000);
  }
}

function spawnFloatText(element, text, type) {
  if (!element) return;
  const rect = element.getBoundingClientRect();
  const ft = document.createElement('div');
  ft.className = `float-text ${type}`;
  ft.textContent = text;
  ft.style.left = (rect.left + rect.width / 2 - 30 + (Math.random() * 20 - 10)) + 'px';
  ft.style.top = (rect.top + rect.height / 3) + 'px';
  document.body.appendChild(ft);
  setTimeout(() => ft.remove(), 1500);
}

// ===== INIT =====
function init() {
  createParticles();
  // Check URL for zone param from hub
  const urlZone = getZoneFromURL();
  buildZoneSelector();
  setZone(urlZone || ZONES[0]);
  updateXPDisplay();
}

function createParticles() {
  const container = document.getElementById('particles');
  for (let i = 0; i < 20; i++) {
    const p = document.createElement('div');
    p.className = 'particle';
    p.style.left = Math.random() * 100 + '%';
    p.style.top = (60 + Math.random() * 40) + '%';
    p.style.animationDelay = (Math.random() * 6) + 's';
    p.style.animationDuration = (4 + Math.random() * 4) + 's';
    p.style.width = (2 + Math.random() * 4) + 'px';
    p.style.height = p.style.width;
    container.appendChild(p);
  }
}

function buildZoneSelector() {
  const sel = document.getElementById('zone-selector');
  sel.innerHTML = '';
  const streak = getHubStreak();
  ZONES.forEach(z => {
    const chip = document.createElement('button');
    const unlocked = streak >= z.needStreak;
    chip.className = 'zone-chip' + (z.id === currentZone.id ? ' active' : '') + (!unlocked ? ' locked' : '');
    if (unlocked) {
      chip.textContent = z.name;
      chip.onclick = () => setZone(z);
    } else {
      chip.textContent = 'üîí ' + z.name;
      chip.onclick = () => {
        chip.classList.add('shake-deny');
        setTimeout(() => chip.classList.remove('shake-deny'), 500);
      };
      chip.title = `Unlocks at ${z.needStreak}-day streak (current: ${streak})`;
    }
    sel.appendChild(chip);
  });
}

function setZone(zone) {
  currentZone = zone;
  document.getElementById('battle-bg').style.backgroundImage = `url('${ZONE_BG[zone.id]}')`;
  document.getElementById('zone-title').textContent = zone.name;
  document.getElementById('zone-subtitle').textContent = zone.desc;
  document.getElementById('modifier-text').textContent = zone.modifier.replace(/^.+?\s/, '');
  document.querySelector('#zone-modifier span').textContent = zone.modifier.split(' ')[0];
  buildZoneSelector();
}

function updateXPDisplay() {
  const rank = gameState.teamRank;
  const xp = gameState.teamXP;
  const nextRankXP = RANK_XP[rank + 1] || RANK_XP[rank];
  const prevRankXP = RANK_XP[rank];
  const progress = rank >= 2 ? 100 : ((xp - prevRankXP) / (nextRankXP - prevRankXP)) * 100;

  document.getElementById('xp-label').textContent = rank >= 2
    ? `Team Rank: LEGENDARY (${xp} XP)`
    : `Team XP: ${xp} / ${nextRankXP}`;
  document.getElementById('xp-bar').style.width = Math.min(100, progress) + '%';

  const badges = document.getElementById('rank-badges');
  badges.innerHTML = RANK_NAMES.map((name, i) => {
    const cls = i === 0 ? 'starter' : i === 1 ? 'expert' : 'legendary';
    return `<span class="rank-badge ${cls} ${i === rank ? 'active' : ''} ${i <= rank ? '' : 'style="opacity:0.3"'}">${i <= rank ? '‚òÖ' : '‚òÜ'} ${name}</span>`;
  }).join('');
}

// ===== SCREEN MANAGEMENT =====
function showScreen(id) {
  document.querySelectorAll('.screen').forEach(s => {
    if (s.classList.contains('active')) {
      s.classList.add('exit');
      setTimeout(() => { s.classList.remove('active', 'exit'); }, 500);
    }
  });
  setTimeout(() => {
    document.getElementById(id).classList.add('active');
  }, 300);
}

// ===== ENCOUNTER START =====
function startEncounter() {
  // Check if current zone is unlocked
  if (!isZoneUnlocked(currentZone)) {
    const scoutBtn = document.getElementById('scout-btn');
    scoutBtn.classList.add('shake-deny');
    setTimeout(() => scoutBtn.classList.remove('shake-deny'), 500);
    return;
  }
  document.body.classList.add('shake');
  setTimeout(() => document.body.classList.remove('shake'), 400);
  drawEnemies();
  setTimeout(() => {
    showScreen('draw-screen');
    setTimeout(() => revealCards(), 600);
  }, 500);
}

function drawEnemies() {
  const pool = ENEMIES_BY_ZONE[currentZone.id] || ENEMIES_BY_ZONE['launch-meadow'];
  const tier = currentZone.tier;
  const commons = pool.filter(e => e.rarity === 'COMMON' || e.rarity === 'UNCOMMON');
  const rares = pool.filter(e => e.rarity === 'RARE' || e.rarity === 'ELITE');
  let drawn = [];
  const shuffledCommons = shuffle([...commons]);
  const shuffledRares = shuffle([...rares]);
  drawn.push(shuffledCommons[0] || pool[0]);
  drawn.push(shuffledCommons[1] || shuffledCommons[0] || pool[1]);
  if (shuffledRares.length > 0) {
    if (Math.random() < 0.15 && pool.some(e => e.rarity === 'ELITE')) {
      drawn.push(pool.find(e => e.rarity === 'ELITE'));
    } else {
      drawn.push(shuffledRares[0]);
    }
  } else {
    drawn.push(shuffledCommons[2] || pool[2] || pool[0]);
  }
  const trioKey = drawn.map(e => e.id).sort().join(',');
  if (trioKey === lastEnemyTrio && pool.length > 3) return drawEnemies();
  lastEnemyTrio = trioKey;
  const seen = new Set();
  drawn = drawn.filter(e => { if (seen.has(e.id)) return false; seen.add(e.id); return true; });
  while (drawn.length < 3) {
    const extra = pool.find(e => !seen.has(e.id));
    if (extra) { drawn.push(extra); seen.add(extra.id); } else break;
  }
  drawnEnemies = drawn.map(e => {
    const stats = TIER_STATS[tier]?.[e.rarity] || TIER_STATS.T1.COMMON;
    return { ...e, stats: { ...stats } };
  });

  const area = document.getElementById('draw-area');
  area.innerHTML = '';
  drawnEnemies.forEach((enemy, i) => {
    const slot = document.createElement('div');
    slot.className = 'draw-card-slot';
    slot.innerHTML = `
      <div class="draw-card-inner" id="draw-card-${i}">
        <div class="draw-card-face draw-card-back"></div>
        <div class="draw-card-face draw-card-front">
          <div class="enemy-portrait" style="background:linear-gradient(135deg, ${ELEMENT_COLORS[enemy.element] || 'var(--type-neutral)'}, rgba(30,15,40,0.8));overflow:hidden;">
            ${ENEMY_IMAGES[enemy.id] ? `<img src="${ENEMY_IMAGES[enemy.id]}" alt="${enemy.name}" style="width:100%;height:100%;object-fit:cover;">` : `<span style="font-size:2.5rem;">${enemy.emoji}</span>`}
          </div>
          <div class="enemy-name">${enemy.name}</div>
          <div class="enemy-info">
            <span class="element-badge" style="background:${ELEMENT_COLORS[enemy.element]};color:#fff;">${enemy.element}</span>
            <span class="rarity-badge" style="background:${RARITY_COLORS[enemy.rarity]};color:#fff;">${enemy.rarity}</span>
          </div>
        </div>
      </div>
    `;
    slot.style.opacity = '0';
    slot.style.transform = 'translateX(100px)';
    area.appendChild(slot);
  });

  document.getElementById('draw-title').textContent = 'Drawing Enemies...';
  document.getElementById('start-battle-btn').style.display = 'none';
}

function revealCards() {
  const slots = document.querySelectorAll('.draw-card-slot');
  slots.forEach((slot, i) => {
    setTimeout(() => {
      slot.style.transition = 'all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1)';
      slot.style.opacity = '1';
      slot.style.transform = 'translateX(0)';
    }, i * 300);
  });
  const flipDelay = slots.length * 300 + 600;
  slots.forEach((slot, i) => {
    setTimeout(() => {
      const inner = document.getElementById(`draw-card-${i}`);
      inner.classList.add('flipped');
      document.body.classList.add('shake');
      setTimeout(() => document.body.classList.remove('shake'), 300);
      // Element burst on reveal
      const rect = slot.getBoundingClientRect();
      spawnElementParticles(drawnEnemies[i].element, rect.left + rect.width/2, rect.top + rect.height/2, 15);
      screenFlash(ELEMENT_RAW_COLORS[drawnEnemies[i].element] || 'white');
    }, flipDelay + i * 800);
  });
  setTimeout(() => {
    document.getElementById('draw-title').textContent = 'Enemies Revealed!';
    document.getElementById('start-battle-btn').style.display = '';
  }, flipDelay + slots.length * 800 + 400);
}

// ===== BATTLE START =====
function startBattle() {
  const HEROES = buildHeroes();
  heroParty = HEROES.map(h => ({
    ...h, currentHp: h.stats.hp, maxHp: h.stats.hp,
    currentStats: { ...h.stats }, statuses: [], shields: [],
    cooldowns: h.moves.map(() => 0), isDefeated: false, team: 'hero',
  }));
  enemyParty = drawnEnemies.map(e => ({
    ...e, currentHp: e.stats.hp, maxHp: e.stats.hp,
    currentStats: { ...e.stats }, statuses: [], shields: [],
    cooldowns: e.moves.map(() => 0), isDefeated: false, team: 'enemy',
  }));
  currentRound = 1; comboCount = 0;
  heroActions = [null, null, null]; selectedHeroIdx = -1;
  battlePhase = 'player'; battleLog = [];
  showScreen('battle-screen');
  setTimeout(() => {
    renderBattleField();
    updateHUD();
    setPhaseIndicator('your-turn', 'Your Turn ‚Äî Pick Moves!');
    if (Math.random() < 0.4) setTimeout(() => triggerBattleEvent(), 1200);
  }, 400);
}

// ===== RENDERING =====
function renderBattleField() { renderEnemyRow(); renderHeroRow(); renderActionPanel(); renderTurnOrder(); }

function renderEnemyRow() {
  const row = document.getElementById('enemy-row');
  row.innerHTML = '';
  enemyParty.forEach((enemy, i) => {
    const card = document.createElement('div');
    card.className = 'battle-card enemy-card' + (enemy.isDefeated ? ' defeated' : '');
    card.id = `enemy-card-${i}`;
    const hpPct = (enemy.currentHp / enemy.maxHp) * 100;
    const hpClass = hpPct <= 25 ? 'low' : hpPct <= 50 ? 'mid' : '';
    card.innerHTML = `
      <div class="card-portrait" style="background:linear-gradient(135deg, ${ELEMENT_COLORS[enemy.element]}, rgba(30,15,40,0.7));overflow:hidden;">
        ${ENEMY_IMAGES[enemy.id] ? `<img src="${ENEMY_IMAGES[enemy.id]}" alt="${enemy.name}" style="width:100%;height:100%;object-fit:cover;">` : `<span class="emoji-portrait">${enemy.emoji}</span>`}
        <span class="card-role-badge" style="color:${RARITY_COLORS[enemy.rarity]}">${enemy.rarity}</span>
      </div>
      <div class="card-name">${enemy.name}</div>
      <div class="card-subtitle">${enemy.role} ¬∑ ${enemy.element}</div>
      <div class="hp-bar-container">
        <div class="hp-bar"><div class="hp-bar-fill ${hpClass}" style="width:${hpPct}%"></div></div>
        <div class="hp-text">${enemy.currentHp}/${enemy.maxHp}</div>
      </div>
      <div class="status-row">${renderStatuses(enemy.statuses)}</div>
    `;
    if (!enemy.isDefeated) card.classList.add('card-enter-enemy');
    card.style.animationDelay = (i * 0.15) + 's';
    row.appendChild(card);
  });
}

function renderHeroRow() {
  const row = document.getElementById('hero-row');
  row.innerHTML = '';
  heroParty.forEach((hero, i) => {
    const card = document.createElement('div');
    card.className = 'battle-card hero-card' + (hero.isDefeated ? ' defeated' : '') + (i === selectedHeroIdx ? ' selected' : '');
    card.id = `hero-card-${i}`;
    const hpPct = (hero.currentHp / hero.maxHp) * 100;
    const hpClass = hpPct <= 25 ? 'low' : hpPct <= 50 ? 'mid' : '';
    const rankStars = '‚òÖ'.repeat(hero.rank + 1);
    card.innerHTML = `
      <div class="card-portrait" style="background:linear-gradient(135deg, ${ELEMENT_COLORS[hero.element]}, rgba(30,15,40,0.7));overflow:hidden;">
        <img src="${hero.img}" alt="${hero.name}" data-hero="${hero.id}" style="width:100%;height:100%;object-fit:cover;object-position:${hero.id === 'william' ? 'center 15%' : 'center'};background:rgba(15,10,28,0.3);">
        <span class="card-rank-star">${rankStars}</span>
      </div>
      <div class="card-name">${hero.name}</div>
      <div class="card-subtitle">${hero.title} ¬∑ ${hero.element}</div>
      <div class="hp-bar-container">
        <div class="hp-bar"><div class="hp-bar-fill ${hpClass}" style="width:${hpPct}%"></div></div>
        <div class="hp-text">${hero.currentHp}/${hero.maxHp}</div>
      </div>
      <div class="status-row">${renderStatuses(hero.statuses)}</div>
      ${heroActions[i] !== null ? '<div style="position:absolute;top:-6px;right:-6px;background:var(--green);color:#000;width:18px;height:18px;border-radius:50%;font-size:0.7rem;display:flex;align-items:center;justify-content:center;font-weight:700;">‚úì</div>' : ''}
    `;
    if (!hero.isDefeated && battlePhase === 'player') {
      card.onclick = () => selectHero(i);
    }
    if (!hero.isDefeated) card.classList.add('card-enter-hero');
    card.style.animationDelay = (i * 0.15) + 's';
    row.appendChild(card);
  });
}

function renderStatuses(statuses) {
  const icons = { burn: 'üî•', blind: 'üëÅÔ∏è‚Äçüó®Ô∏è', root: 'üåø', weaken: '‚¨áÔ∏è', chill: '‚ùÑÔ∏è', shock: '‚ö°', focus: 'üéØ', guard: 'üõ°Ô∏è' };
  return statuses.map(s => `<span class="status-icon" style="color:${s.type === 'focus' ? 'var(--cyan)' : s.type === 'guard' ? 'var(--blue)' : 'var(--orange)'}">${icons[s.type] || '?'} ${s.duration}</span>`).join('');
}

function renderTurnOrder() {
  const bar = document.getElementById('turn-order-bar');
  const allUnits = [...heroParty.map((h,i) => ({...h, idx: i, side: 'hero'})), ...enemyParty.map((e,i) => ({...e, idx: i, side: 'enemy'}))];
  const alive = allUnits.filter(u => !u.isDefeated);
  alive.sort((a, b) => b.currentStats.spd - a.currentStats.spd);
  bar.innerHTML = alive.map((u, i) => {
    const imgSrc = u.side === 'hero' ? u.img : (ENEMY_IMAGES[u.id] || '');
    const inner = imgSrc ? `<img src="${imgSrc}" alt="${u.name}">` : `<span style="font-size:0.8rem;">${u.emoji || '?'}</span>`;
    return `<div class="turn-order-icon ${i === 0 ? 'active-turn' : ''}" style="border-color:${u.side === 'hero' ? 'var(--green)' : 'var(--red)'}">${inner}</div>${i < alive.length - 1 ? '<span class="turn-order-arrow">‚ñ∏</span>' : ''}`;
  }).join('');
}

function renderActionPanel() {
  const panel = document.getElementById('action-buttons');
  const label = document.getElementById('action-label');
  panel.innerHTML = '';
  if (selectedHeroIdx < 0 || heroParty[selectedHeroIdx]?.isDefeated) {
    label.textContent = 'Select a hero to see their moves';
    return;
  }
  const hero = heroParty[selectedHeroIdx];
  label.textContent = `${hero.name}'s Moves:`;
  hero.moves.forEach((move, mi) => {
    const onCd = hero.cooldowns[mi] > 0;
    const btn = document.createElement('button');
    btn.className = 'action-btn' + (move.type === 'shield' || move.type === 'buff' ? '' : '') + (heroActions[selectedHeroIdx] === mi ? ' selected' : '');
    btn.disabled = onCd;
    btn.innerHTML = `
      <span class="move-name" style="color:${ELEMENT_COLORS[move.element || hero.element]}">${move.name}</span>
      <span class="move-desc">${move.desc}</span>
      ${move.keywords ? `<span style="font-size:0.5rem;color:var(--muted);">${move.keywords.join(' ¬∑ ')}</span>` : ''}
      ${onCd ? `<span class="cooldown-badge">${hero.cooldowns[mi]}</span>` : ''}
    `;
    btn.onclick = () => selectMove(selectedHeroIdx, mi);
    panel.appendChild(btn);
  });
  // Guard button
  const guardBtn = document.createElement('button');
  guardBtn.className = 'action-btn guard-btn' + (heroActions[selectedHeroIdx] === 'guard' ? ' selected' : '');
  guardBtn.innerHTML = `<span class="move-name" style="color:var(--blue);">Guard</span><span class="move-desc">Reduce damage this round.</span>`;
  guardBtn.onclick = () => selectMove(selectedHeroIdx, 'guard');
  panel.appendChild(guardBtn);

  // Show Execute button if all heroes have actions
  const allAssigned = heroParty.every((h, i) => h.isDefeated || heroActions[i] !== null);
  if (allAssigned) {
    const confirm = document.createElement('button');
    confirm.className = 'confirm-btn';
    confirm.textContent = 'Execute Round!';
    confirm.onclick = executeRound;
    panel.appendChild(confirm);
  }
}

function selectHero(idx) {
  if (battlePhase !== 'player' || heroParty[idx].isDefeated) return;
  selectedHeroIdx = idx;
  renderHeroRow();
  renderActionPanel();
}

function selectMove(heroIdx, moveIdx) {
  heroActions[heroIdx] = moveIdx;
  renderHeroRow();
  renderActionPanel();
}

function setPhaseIndicator(cls, text) {
  const el = document.getElementById('phase-indicator');
  el.textContent = text;
  el.className = 'phase-indicator ' + cls;
}

function updateHUD() {
  document.getElementById('round-counter').textContent = `Round ${currentRound}`;
  const combo = document.getElementById('combo-meter');
  if (comboCount >= 2) {
    combo.textContent = `Combo x${comboCount}`;
    combo.classList.add('visible');
  } else {
    combo.classList.remove('visible');
  }
}

// ===== BATTLE EXECUTION =====
async function executeRound() {
  battlePhase = 'executing';
  setPhaseIndicator('', '‚öîÔ∏è Battle!');

  // Phase 1: Hero actions (animated sequentially)
  for (let i = 0; i < heroParty.length; i++) {
    if (heroParty[i].isDefeated) continue;
    await resolveHeroAction(i);
    await sleep(300);
    if (checkBattleEnd()) return;
  }

  // Phase 2: Enemy actions
  setPhaseIndicator('enemy-turn', 'Enemy Turn...');
  await sleep(500);
  for (let i = 0; i < enemyParty.length; i++) {
    if (enemyParty[i].isDefeated) continue;
    await resolveEnemyAction(i);
    await sleep(400);
    if (checkBattleEnd()) return;
  }

  // Phase 3: End of round
  await endOfRound();
  if (checkBattleEnd()) return;

  // Next round
  currentRound++;
  heroActions = [null, null, null];
  selectedHeroIdx = -1;
  battlePhase = 'player';
  updateHUD();
  renderBattleField();
  setPhaseIndicator('your-turn', 'Your Turn ‚Äî Pick Moves!');
  document.getElementById('round-counter').classList.add('round-pulse');
  setTimeout(() => document.getElementById('round-counter').classList.remove('round-pulse'), 600);

  // Random battle event
  if (currentRound === 3 && Math.random() < 0.5) {
    setTimeout(() => triggerBattleEvent(), 800);
  }
}

async function resolveHeroAction(heroIdx) {
  const hero = heroParty[heroIdx];
  const action = heroActions[heroIdx];
  if (action === null) return;

  const heroCard = document.getElementById(`hero-card-${heroIdx}`);

  if (action === 'guard') {
    // Guard animation
    heroCard.classList.add('guard-stance');
    setTimeout(() => heroCard.classList.remove('guard-stance'), 600);
    spawnFloatText(heroCard, 'üõ°Ô∏è Guard!', 'guard-text');
    hero.statuses.push({ type: 'guard', duration: 1 });
    addLog(`${hero.name} guards!`);
    await sleep(500);
    renderBattleField();
    return;
  }

  const move = hero.moves[action];
  if (!move) return;

  // Set cooldown
  if (move.maxCd > 0) hero.cooldowns[action] = move.maxCd;

  if (move.type === 'damage' || move.type === 'control') {
    const targets = move.target === 'all_enemies'
      ? enemyParty.filter(e => !e.isDefeated)
      : [findLaneTarget(heroIdx)];

    // Lunge animation
    heroCard.classList.add('attack-lunge-up');
    await sleep(250);

    for (const target of targets) {
      if (!target || target.isDefeated) continue;
      const ti = enemyParty.indexOf(target);
      const targetCard = document.getElementById(`enemy-card-${ti}`);
      const result = calcDamage(hero, target, move);

      // Element particles at impact
      const tRect = targetCard?.getBoundingClientRect();
      if (tRect) spawnElementParticles(move.element || hero.element, tRect.left + tRect.width/2, tRect.top + tRect.height/2);

      // Hit animation based on effectiveness
      if (result.effectiveness > 1) {
        targetCard?.classList.add('super-hit');
        setTimeout(() => targetCard?.classList.remove('super-hit'), 500);
        screenFlash(ELEMENT_RAW_COLORS[move.element || hero.element]);
        document.body.classList.add('heavy-shake');
        setTimeout(() => document.body.classList.remove('heavy-shake'), 600);
        spawnFloatText(targetCard, 'SUPER EFFECTIVE!', 'super');
        comboCount++;
      } else if (result.effectiveness < 1) {
        targetCard?.classList.add('resist-hit');
        setTimeout(() => targetCard?.classList.remove('resist-hit'), 400);
        spawnFloatText(targetCard, 'Resisted...', 'resist');
        comboCount = 0;
      } else {
        targetCard?.classList.add('hit-flash');
        setTimeout(() => targetCard?.classList.remove('hit-flash'), 350);
        document.body.classList.add('shake');
        setTimeout(() => document.body.classList.remove('shake'), 400);
      }

      await sleep(200);
      spawnFloatText(targetCard, `-${result.damage}`, 'damage');
      target.currentHp = Math.max(0, target.currentHp - result.damage);
      addLog(`${hero.name} uses ${move.name} on ${target.name} for ${result.damage} damage!`);

      // Status effect
      if (move.statusChance && Math.random() < move.statusChance) {
        target.statuses.push({ type: move.statusType, duration: 2 });
        spawnFloatText(targetCard, move.statusType.toUpperCase() + '!', 'status');
        addLog(`${target.name} is ${move.statusType}ed!`);
      }

      // KO check
      if (target.currentHp <= 0) {
        target.isDefeated = true;
        comboCount++;
        await sleep(200);
        targetCard?.classList.add('ko-shatter');
        spawnFloatText(targetCard, 'K.O.!', 'ko');
        screenFlash('rgba(239,68,68,0.3)');
        document.body.classList.add('heavy-shake');
        setTimeout(() => document.body.classList.remove('heavy-shake'), 600);
        spawnXPOrbs(targetCard, 8);
        addLog(`${target.name} is defeated!`);
        await sleep(600);
      }

      renderBattleField();
      await sleep(200);
    }

    setTimeout(() => heroCard?.classList.remove('attack-lunge-up'), 500);
    updateHUD();

  } else if (move.type === 'heal') {
    const targets = move.target === 'all_allies'
      ? heroParty.filter(h => !h.isDefeated)
      : [findLowestHPAlly()];

    heroCard.classList.add('heal-glow');
    setTimeout(() => heroCard.classList.remove('heal-glow'), 800);

    for (const target of targets) {
      if (!target) continue;
      const ti = heroParty.indexOf(target);
      const tCard = document.getElementById(`hero-card-${ti}`);
      const healAmt = Math.floor(move.power * (1 + hero.currentStats.atk * 0.02));
      target.currentHp = Math.min(target.maxHp, target.currentHp + healAmt);
      tCard?.classList.add('heal-glow');
      setTimeout(() => tCard?.classList.remove('heal-glow'), 800);
      spawnFloatText(tCard, `+${healAmt}`, 'heal');
      addLog(`${hero.name} heals ${target.name} for ${healAmt}!`);
    }
    renderBattleField();

  } else if (move.type === 'shield') {
    const target = findLowestHPAlly();
    if (target) {
      const ti = heroParty.indexOf(target);
      const tCard = document.getElementById(`hero-card-${ti}`);
      target.shields.push({ amount: move.power, duration: 2 });
      tCard?.classList.add('shield-dome');
      setTimeout(() => tCard?.classList.remove('shield-dome'), 800);
      spawnFloatText(tCard, `+${move.power} Shield`, 'guard-text');
      addLog(`${hero.name} shields ${target.name} for ${move.power}!`);
    }
    renderBattleField();

  } else if (move.type === 'buff') {
    const targets = move.target === 'all_allies'
      ? heroParty.filter(h => !h.isDefeated)
      : [hero];

    for (const target of targets) {
      target.statuses.push({ type: move.effect || 'focus', duration: 2 });
      const ti = heroParty.indexOf(target);
      const tCard = document.getElementById(`hero-card-${ti}`);
      spawnFloatText(tCard, (move.effect || 'focus').toUpperCase() + '!', 'status');
    }

    // If move also heals (like Hero's Resolve)
    if (move.keywords?.includes('Heal') && move.power > 0) {
      for (const target of targets) {
        const healAmt = Math.floor(move.power * 0.5);
        target.currentHp = Math.min(target.maxHp, target.currentHp + healAmt);
        const ti = heroParty.indexOf(target);
        const tCard = document.getElementById(`hero-card-${ti}`);
        spawnFloatText(tCard, `+${healAmt}`, 'heal');
      }
    }

    addLog(`${hero.name} uses ${move.name}!`);
    renderBattleField();
  }
}

async function resolveEnemyAction(enemyIdx) {
  const enemy = enemyParty[enemyIdx];
  const enemyCard = document.getElementById(`enemy-card-${enemyIdx}`);
  const aliveHeroes = heroParty.filter(h => !h.isDefeated);
  if (aliveHeroes.length === 0) return;

  // AI: pick move
  let move, target;
  const role = enemy.role;
  if (role === 'TRICKSTER' || role === 'SUPPORT') {
    // Target lowest HP hero
    target = aliveHeroes.reduce((a, b) => a.currentHp < b.currentHp ? a : b);
    move = enemy.moves[Math.random() < 0.6 ? 0 : (enemy.moves.length > 1 ? 1 : 0)];
  } else if (role === 'TANK') {
    // Guard more often when low HP
    const hpPct = enemy.currentHp / enemy.maxHp;
    if (hpPct < 0.4 && enemy.moves.some(m => m.type === 'buff')) {
      move = enemy.moves.find(m => m.type === 'buff');
    } else {
      move = enemy.moves[0];
    }
    target = aliveHeroes[Math.floor(Math.random() * aliveHeroes.length)];
  } else {
    // Bruiser/Caster/Skirmisher: attack highest ATK hero
    target = aliveHeroes.reduce((a, b) => a.currentStats.atk > b.currentStats.atk ? a : b);
    move = enemy.moves[0];
  }

  if (!move) return;

  // Enemy lunge animation
  enemyCard?.classList.add('attack-lunge-down');
  await sleep(250);

  if (move.type === 'damage' || move.type === 'control' || move.type === 'debuff') {
    const ti = heroParty.indexOf(target);
    const targetCard = document.getElementById(`hero-card-${ti}`);
    const result = calcDamage(enemy, target, move);

    // Check guard
    let finalDmg = result.damage;
    const guardStatus = target.statuses.find(s => s.type === 'guard');
    if (guardStatus) {
      finalDmg = Math.floor(finalDmg * 0.5);
      spawnFloatText(targetCard, 'Guarded!', 'guard-text');
    }

    // Check shield
    let shieldAbsorb = 0;
    while (target.shields.length > 0 && finalDmg > 0) {
      const shield = target.shields[0];
      if (shield.amount >= finalDmg) {
        shield.amount -= finalDmg;
        shieldAbsorb += finalDmg;
        finalDmg = 0;
      } else {
        finalDmg -= shield.amount;
        shieldAbsorb += shield.amount;
        target.shields.shift();
      }
    }
    if (shieldAbsorb > 0) spawnFloatText(targetCard, `Shield -${shieldAbsorb}`, 'guard-text');

    // Hit animation
    const tRect = targetCard?.getBoundingClientRect();
    if (tRect) spawnElementParticles(enemy.element, tRect.left + tRect.width/2, tRect.top + tRect.height/2, 10);
    targetCard?.classList.add('hit-flash');
    setTimeout(() => targetCard?.classList.remove('hit-flash'), 350);
    document.body.classList.add('shake');
    setTimeout(() => document.body.classList.remove('shake'), 400);

    await sleep(200);
    if (finalDmg > 0) {
      spawnFloatText(targetCard, `-${finalDmg}`, 'damage');
      target.currentHp = Math.max(0, target.currentHp - finalDmg);
    }
    addLog(`${enemy.name} uses ${move.name} on ${target.name} for ${finalDmg} damage!`);

    // Status
    if (move.statusChance && Math.random() < move.statusChance) {
      target.statuses.push({ type: move.statusType, duration: 2 });
      spawnFloatText(targetCard, move.statusType.toUpperCase() + '!', 'status');
    }

    // KO
    if (target.currentHp <= 0) {
      target.isDefeated = true;
      await sleep(200);
      targetCard?.classList.add('ko-shatter');
      spawnFloatText(targetCard, 'K.O.!', 'ko');
      screenFlash('rgba(239,68,68,0.3)');
      document.body.classList.add('heavy-shake');
      setTimeout(() => document.body.classList.remove('heavy-shake'), 600);
      addLog(`${target.name} is defeated!`);
      await sleep(600);
    }

  } else if (move.type === 'buff') {
    enemy.statuses.push({ type: move.effect || 'guard', duration: 2 });
    enemyCard?.classList.add('guard-stance');
    setTimeout(() => enemyCard?.classList.remove('guard-stance'), 600);
    spawnFloatText(enemyCard, (move.effect || 'guard').toUpperCase() + '!', 'status');
    addLog(`${enemy.name} uses ${move.name}!`);

  } else if (move.type === 'heal') {
    const healTarget = enemyParty.filter(e => !e.isDefeated).reduce((a, b) => a.currentHp < b.currentHp ? a : b);
    if (healTarget) {
      const healAmt = move.power;
      healTarget.currentHp = Math.min(healTarget.maxHp, healTarget.currentHp + healAmt);
      const hti = enemyParty.indexOf(healTarget);
      const htCard = document.getElementById(`enemy-card-${hti}`);
      htCard?.classList.add('heal-glow');
      setTimeout(() => htCard?.classList.remove('heal-glow'), 800);
      spawnFloatText(htCard, `+${healAmt}`, 'heal');
      addLog(`${enemy.name} heals ${healTarget.name} for ${healAmt}!`);
    }
  }

  setTimeout(() => enemyCard?.classList.remove('attack-lunge-down'), 500);
  renderBattleField();
}

// ===== DAMAGE CALC =====
function calcDamage(attacker, defender, move) {
  const atk = attacker.currentStats.atk;
  const def = defender.currentStats.def;
  const power = move.power || 10;
  const focusBuff = attacker.statuses.find(s => s.type === 'focus') ? 1.15 : 1;
  const weakenDebuff = attacker.statuses.find(s => s.type === 'weaken') ? 0.8 : 1;
  const moveElement = move.element || attacker.element;
  const effectiveness = TYPE_CHART[moveElement]?.[defender.element] || 1;
  let dmg = Math.floor(((power + atk * 1.5) - def * 0.5) * focusBuff * weakenDebuff * effectiveness);
  dmg = Math.max(1, dmg + Math.floor(Math.random() * 5 - 2));
  return { damage: dmg, effectiveness };
}

function findLaneTarget(heroIdx) {
  if (!enemyParty[heroIdx]?.isDefeated) return enemyParty[heroIdx];
  return enemyParty.find(e => !e.isDefeated) || enemyParty[0];
}

function findLowestHPAlly() {
  return heroParty.filter(h => !h.isDefeated).reduce((a, b) => {
    const aPct = a.currentHp / a.maxHp;
    const bPct = b.currentHp / b.maxHp;
    return aPct < bPct ? a : b;
  }, heroParty[0]);
}

// ===== END OF ROUND =====
async function endOfRound() {
  // Tick status effects
  for (const unit of [...heroParty, ...enemyParty]) {
    if (unit.isDefeated) continue;
    // Burn damage
    const burnStatus = unit.statuses.find(s => s.type === 'burn');
    if (burnStatus) {
      const burnDmg = Math.floor(unit.maxHp * 0.06);
      unit.currentHp = Math.max(0, unit.currentHp - burnDmg);
      const idx = unit.team === 'hero' ? heroParty.indexOf(unit) : enemyParty.indexOf(unit);
      const card = document.getElementById(`${unit.team === 'hero' ? 'hero' : 'enemy'}-card-${idx}`);
      card?.classList.add('burn-tick');
      setTimeout(() => card?.classList.remove('burn-tick'), 500);
      spawnFloatText(card, `-${burnDmg} üî•`, 'damage');
      addLog(`${unit.name} takes ${burnDmg} burn damage!`);
      if (unit.currentHp <= 0) {
        unit.isDefeated = true;
        card?.classList.add('ko-shatter');
        spawnFloatText(card, 'K.O.!', 'ko');
        await sleep(500);
      }
    }
    // Tick durations
    unit.statuses = unit.statuses.filter(s => { s.duration--; return s.duration > 0; });
    unit.shields = unit.shields.filter(s => { s.duration--; return s.duration > 0; });
  }

  // Reduce cooldowns
  for (const hero of heroParty) {
    hero.cooldowns = hero.cooldowns.map(cd => Math.max(0, cd - 1));
  }
  for (const enemy of enemyParty) {
    enemy.cooldowns = enemy.cooldowns.map(cd => Math.max(0, cd - 1));
  }

  renderBattleField();
}

// ===== BATTLE END =====
function checkBattleEnd() {
  const heroesAlive = heroParty.some(h => !h.isDefeated);
  const enemiesAlive = enemyParty.some(e => !e.isDefeated);
  if (!enemiesAlive) { setTimeout(() => showVictory(), 800); return true; }
  if (!heroesAlive) { setTimeout(() => showDefeat(), 800); return true; }
  return false;
}

function showVictory() {
  const baseXP = 50;
  const roundBonus = Math.max(0, 10 * (6 - currentRound));
  const comboBonus = comboCount * 5;
  const totalXP = baseXP + roundBonus + comboBonus;

  // Update game state
  const oldRank = gameState.teamRank;
  gameState.teamXP += totalXP;
  gameState.wins++;
  gameState.totalBattles++;

  // Check for rank up
  let newRank = oldRank;
  if (gameState.teamXP >= RANK_XP[2] && oldRank < 2) newRank = 2;
  else if (gameState.teamXP >= RANK_XP[1] && oldRank < 1) newRank = 1;

  if (newRank > oldRank) {
    gameState.teamRank = newRank;
    pendingEvolutions.push({ oldRank, newRank });
  }
  saveGameState();

  // Victory screen
  spawnConfetti(80);
  screenFlash('rgba(255,211,110,0.3)');
  showScreen('result-screen');
  const title = document.getElementById('result-title');
  title.textContent = 'Victory!';
  title.className = 'result-title win';
  document.getElementById('result-subtitle').textContent = 'William and his team triumphed!';

  const rewards = document.getElementById('reward-list');
  rewards.innerHTML = '';
  const items = [
    { icon: '‚≠ê', text: 'Base XP', value: `+${baseXP}` },
    { icon: '‚ö°', text: `Speed Bonus (${currentRound} rounds)`, value: `+${roundBonus}` },
    { icon: 'üî•', text: `Combo Bonus (x${comboCount})`, value: `+${comboBonus}` },
    { icon: 'üèÜ', text: 'Total XP', value: `+${totalXP}` },
    { icon: 'üéñÔ∏è', text: 'Battle Badge', value: `Win #${gameState.wins}` },
  ];
  if (comboCount >= 3) items.push({ icon: 'üíé', text: 'Streak Bonus!', value: 'Card Frame' });

  items.forEach((item, i) => {
    const div = document.createElement('div');
    div.className = 'reward-item';
    div.style.animationDelay = (i * 0.15) + 's';
    div.innerHTML = `<span class="reward-icon">${item.icon}</span><span class="reward-text">${item.text}</span><span class="reward-value">${item.value}</span>`;
    rewards.appendChild(div);
  });

  // Check if evolution should trigger
  if (pendingEvolutions.length > 0) {
    setTimeout(() => showEvolution(), 3000);
  }
}

function showDefeat() {
  gameState.totalBattles++;
  saveGameState();
  showScreen('result-screen');
  const title = document.getElementById('result-title');
  title.textContent = 'Retreat!';
  title.className = 'result-title lose';
  document.getElementById('result-subtitle').textContent = 'Complete a routine mission to gain +10 HP for next battle!';

  const rewards = document.getElementById('reward-list');
  rewards.innerHTML = '';
  const items = [
    { icon: '‚≠ê', text: 'Participation XP', value: '+15' },
    { icon: 'üí°', text: 'Tip', value: 'Try type advantages!' },
  ];
  gameState.teamXP += 15;
  saveGameState();
  items.forEach((item, i) => {
    const div = document.createElement('div');
    div.className = 'reward-item';
    div.style.animationDelay = (i * 0.15) + 's';
    div.innerHTML = `<span class="reward-icon">${item.icon}</span><span class="reward-text">${item.text}</span><span class="reward-value">${item.value}</span>`;
    rewards.appendChild(div);
  });
}

// ===== EVOLUTION SCREEN =====
function showEvolution() {
  const evo = pendingEvolutions.shift();
  if (!evo) return;

  showScreen('evolution-screen');
  screenFlash('rgba(255,211,110,0.5)');
  spawnConfetti(100);

  const container = document.getElementById('evo-container');
  container.innerHTML = '';

  HERO_BASE.forEach(hero => {
    const oldImg = IMG[hero.id][evo.oldRank];
    const newImg = IMG[hero.id][evo.newRank];
    const oldTitle = RANK_TITLES[hero.id][evo.oldRank];
    const newTitle = RANK_TITLES[hero.id][evo.newRank];

    const group = document.createElement('div');
    group.style.cssText = 'display:flex;flex-direction:column;align-items:center;gap:8px;';
    group.innerHTML = `
      <div style="display:flex;align-items:center;gap:16px;">
        <div class="evo-card" style="width:100px;height:130px;"><img src="${oldImg}" alt="${oldTitle}"></div>
        <span class="evo-arrow">‚û§</span>
        <div class="evo-card" style="width:120px;height:155px;border-color:${evo.newRank === 2 ? 'var(--gold)' : 'var(--blue)'}"><img src="${newImg}" alt="${newTitle}"></div>
      </div>
      <div style="font-family:var(--font-display);color:var(--gold);font-size:0.9rem;">${hero.name}: ${newTitle}</div>
    `;
    container.appendChild(group);
  });

  document.getElementById('evo-title').textContent = `RANK UP: ${RANK_NAMES[evo.newRank].toUpperCase()}!`;
}

function continueAfterEvolution() {
  if (pendingEvolutions.length > 0) {
    showEvolution();
  } else {
    resetBattle();
  }
}

// ===== BATTLE EVENTS =====
function triggerBattleEvent() {
  const event = BATTLE_EVENTS[Math.floor(Math.random() * BATTLE_EVENTS.length)];
  document.getElementById('event-title').textContent = event.title;
  document.getElementById('event-desc').textContent = event.desc;
  const banner = document.getElementById('battle-event-banner');
  banner.classList.add('show');
  document.body.classList.add('shake');
  setTimeout(() => document.body.classList.remove('shake'), 400);
  setTimeout(() => banner.classList.remove('show'), 3000);
}

// ===== RESET =====
function resetBattle() {
  showScreen('scout-screen');
  updateXPDisplay();
}

// ===== UTILITIES =====
function shuffle(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

function addLog(text) {
  battleLog.push(text);
  const log = document.getElementById('battle-log');
  log.innerHTML = battleLog.map(l => `<div class="log-entry">${l}</div>`).join('');
  log.scrollTop = log.scrollHeight;
  log.classList.add('visible');
}

// ===== NAVIGATION =====
function goToHub() {
  window.location.href = './index.html';
}

// Update streak display in nav
function updateStreakDisplay() {
  const streak = getHubStreak();
  const el = document.getElementById('streak-display');
  if (el) el.textContent = streak;
}

// ===== START =====
updateStreakDisplay();
init();
</script>
</body>
</html>
